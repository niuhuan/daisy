// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments,
    clippy::match_single_binding,
    clippy::clone_on_copy,
    clippy::let_unit_value,
    clippy::deref_addrof,
    clippy::explicit_auto_deref,
    clippy::borrow_deref_ref,
    clippy::needless_borrow
)]

// Section: imports

use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
    default_stream_sink_codec = SseCodec,
    default_rust_opaque = RustOpaqueMoi,
    default_rust_auto_opaque = RustAutoOpaqueMoi,
);
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.9.0";
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_CONTENT_HASH: i32 = -894247475;

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire__crate__api__bridge__all_downloads_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "all_downloads",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::bridge::all_downloads().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bridge__author_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "author",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_id = <i32>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::bridge::author(api_id).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bridge__auto_clean_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "auto_clean",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_time = <i64>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::bridge::auto_clean(api_time).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bridge__comic_categories_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "comic_categories",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::bridge::comic_categories().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bridge__comic_chapter_detail_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "comic_chapter_detail",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_comic_id = <i32>::sse_decode(&mut deserializer);
            let api_chapter_id = <i32>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::bridge::comic_chapter_detail(api_comic_id, api_chapter_id)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bridge__comic_classify_filters_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "comic_classify_filters",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::bridge::comic_classify_filters().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bridge__comic_classify_filters_old_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "comic_classify_filters_old",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::bridge::comic_classify_filters_old().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bridge__comic_classify_with_level_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "comic_classify_with_level",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_categories = <Vec<i32>>::sse_decode(&mut deserializer);
            let api_sort = <i64>::sse_decode(&mut deserializer);
            let api_page = <i64>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::bridge::comic_classify_with_level(
                            api_categories,
                            api_sort,
                            api_page,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bridge__comic_detail_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "comic_detail",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_id = <i32>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::bridge::comic_detail(api_id).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bridge__comic_rank_list_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "comic_rank_list",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::bridge::comic_rank_list().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bridge__comic_recommend_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "comic_recommend",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::bridge::comic_recommend().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bridge__comic_search_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "comic_search",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_content = <String>::sse_decode(&mut deserializer);
            let api_page = <i64>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::bridge::comic_search(api_content, api_page).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bridge__comic_update_list_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "comic_update_list",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_sort = <i64>::sse_decode(&mut deserializer);
            let api_page = <i64>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::bridge::comic_update_list(api_sort, api_page).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bridge__comic_view_page_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "comic_view_page",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_comic_id = <i32>::sse_decode(&mut deserializer);
            let api_chapter_id = <i32>::sse_decode(&mut deserializer);
            let api_chapter_title = <String>::sse_decode(&mut deserializer);
            let api_chapter_order = <i32>::sse_decode(&mut deserializer);
            let api_page_rank = <i32>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::bridge::comic_view_page(
                            api_comic_id,
                            api_chapter_id,
                            api_chapter_title,
                            api_chapter_order,
                            api_page_rank,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bridge__comment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "comment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_obj_type = <i64>::sse_decode(&mut deserializer);
            let api_obj_id = <i32>::sse_decode(&mut deserializer);
            let api_hot = <bool>::sse_decode(&mut deserializer);
            let api_page = <i64>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::bridge::comment(
                            api_obj_type,
                            api_obj_id,
                            api_hot,
                            api_page,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bridge__comment_v3_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "comment_v3",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_obj_type = <i64>::sse_decode(&mut deserializer);
            let api_obj_id = <i32>::sse_decode(&mut deserializer);
            let api_page = <i64>::sse_decode(&mut deserializer);
            let api_limit = <i64>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::bridge::comment_v3(
                            api_obj_type,
                            api_obj_id,
                            api_page,
                            api_limit,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bridge__comment_v3_add_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "comment_v3_add",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_obj_type = <i64>::sse_decode(&mut deserializer);
            let api_obj_id = <i32>::sse_decode(&mut deserializer);
            let api_content = <String>::sse_decode(&mut deserializer);
            let api_to_comment_id = <i32>::sse_decode(&mut deserializer);
            let api_to_uid = <i32>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::bridge::comment_v3_add(
                            api_obj_type,
                            api_obj_id,
                            api_content,
                            api_to_comment_id,
                            api_to_uid,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bridge__create_download_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "create_download",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_buff = <crate::anime_home::proto::ComicDetail>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::bridge::create_download(api_buff).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bridge__delete_download_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "delete_download",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_id = <i32>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::bridge::delete_download(api_id).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bridge__desktop_root_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "desktop_root",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::bridge::desktop_root()?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__bridge__download_comic_chapters_by_comic_id_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "download_comic_chapters_by_comic_id",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_id = <i32>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::bridge::download_comic_chapters_by_comic_id(api_id).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bridge__download_comic_page_by_chapter_id_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "download_comic_page_by_chapter_id",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_chapter_id = <i32>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::bridge::download_comic_page_by_chapter_id(api_chapter_id)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__simple__greet_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "greet",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_name = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::simple::greet(api_name))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bridge__http_get_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "http_get",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_url = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::bridge::http_get(api_url).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bridge__init_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "init",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_root = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok({
                            crate::api::bridge::init(api_root).await;
                        })?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__simple__init_app_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "init_app",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok({
                        crate::api::simple::init_app();
                    })?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__bridge__load_cache_image_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "load_cache_image",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_url = <String>::sse_decode(&mut deserializer);
            let api_useful = <String>::sse_decode(&mut deserializer);
            let api_extends_field_int_first = <Option<i32>>::sse_decode(&mut deserializer);
            let api_extends_field_int_second = <Option<i32>>::sse_decode(&mut deserializer);
            let api_extends_field_int_third = <Option<i32>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::bridge::load_cache_image(
                            api_url,
                            api_useful,
                            api_extends_field_int_first,
                            api_extends_field_int_second,
                            api_extends_field_int_third,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bridge__load_comic_id_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "load_comic_id",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_comic_id_string = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::bridge::load_comic_id(api_comic_id_string).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bridge__load_comic_view_logs_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "load_comic_view_logs",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_page = <i64>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::bridge::load_comic_view_logs(api_page).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bridge__load_novel_view_logs_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "load_novel_view_logs",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_page = <i64>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::bridge::load_novel_view_logs(api_page).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bridge__load_property_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "load_property",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_k = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::bridge::load_property(api_k).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bridge__news_categories_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "news_categories",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::bridge::news_categories().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bridge__news_list_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "news_list",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_id = <i64>::sse_decode(&mut deserializer);
            let api_page = <i64>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::bridge::news_list(api_id, api_page).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bridge__novel_categories_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "novel_categories",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::bridge::novel_categories().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bridge__novel_chapters_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "novel_chapters",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_id = <i32>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::bridge::novel_chapters(api_id).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bridge__novel_content_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "novel_content",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_volume_id = <i32>::sse_decode(&mut deserializer);
            let api_chapter_id = <i32>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::bridge::novel_content(api_volume_id, api_chapter_id)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bridge__novel_detail_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "novel_detail",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_id = <i32>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::bridge::novel_detail(api_id).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bridge__novel_list_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "novel_list",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_category = <i32>::sse_decode(&mut deserializer);
            let api_process = <i64>::sse_decode(&mut deserializer);
            let api_sort = <i64>::sse_decode(&mut deserializer);
            let api_page = <i64>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::bridge::novel_list(
                            api_category,
                            api_process,
                            api_sort,
                            api_page,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bridge__novel_search_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "novel_search",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_content = <String>::sse_decode(&mut deserializer);
            let api_page = <i64>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::bridge::novel_search(api_content, api_page).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bridge__novel_view_page_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "novel_view_page",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_novel_id = <i32>::sse_decode(&mut deserializer);
            let api_volume_id = <i32>::sse_decode(&mut deserializer);
            let api_volume_title = <String>::sse_decode(&mut deserializer);
            let api_volume_order = <i32>::sse_decode(&mut deserializer);
            let api_chapter_id = <i32>::sse_decode(&mut deserializer);
            let api_chapter_title = <String>::sse_decode(&mut deserializer);
            let api_chapter_order = <i32>::sse_decode(&mut deserializer);
            let api_progress = <i64>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::bridge::novel_view_page(
                            api_novel_id,
                            api_volume_id,
                            api_volume_title,
                            api_volume_order,
                            api_chapter_id,
                            api_chapter_title,
                            api_chapter_order,
                            api_progress,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bridge__pre_login_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "pre_login",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_nickname = <String>::sse_decode(&mut deserializer);
            let api_passwd = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::bridge::pre_login(api_nickname, api_passwd).await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bridge__re_login_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "re_login",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_nickname = <String>::sse_decode(&mut deserializer);
            let api_passwd = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::bridge::re_login(api_nickname, api_passwd).await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bridge__renew_all_downloads_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "renew_all_downloads",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::bridge::renew_all_downloads().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bridge__save_property_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "save_property",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_k = <String>::sse_decode(&mut deserializer);
            let api_v = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::bridge::save_property(api_k, api_v).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bridge__subscribe_add_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "subscribe_add",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_obj_type = <String>::sse_decode(&mut deserializer);
            let api_obj_id = <i32>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::bridge::subscribe_add(api_obj_type, api_obj_id).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bridge__subscribe_cancel_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "subscribe_cancel",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_obj_type = <String>::sse_decode(&mut deserializer);
            let api_obj_id = <i32>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::bridge::subscribe_cancel(api_obj_type, api_obj_id).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bridge__subscribed_list_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "subscribed_list",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_sub_type = <i64>::sse_decode(&mut deserializer);
            let api_page = <i64>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::bridge::subscribed_list(api_sub_type, api_page).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bridge__subscribed_obj_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "subscribed_obj",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_sub_type = <i64>::sse_decode(&mut deserializer);
            let api_obj_id = <i32>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::bridge::subscribed_obj(api_sub_type, api_obj_id).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bridge__task_index_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "task_index",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::bridge::task_index().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bridge__task_sign_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "task_sign",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::bridge::task_sign().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bridge__view_log_by_comic_id_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "view_log_by_comic_id",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_comic_id = <i32>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::bridge::view_log_by_comic_id(api_comic_id).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bridge__view_log_by_novel_id_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "view_log_by_novel_id",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_novel_id = <i32>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::bridge::view_log_by_novel_id(api_novel_id).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}

// Section: dart2rust

impl SseDecode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::anyhow::anyhow!("{}", inner);
    }
}

impl SseDecode for std::collections::HashMap<String, crate::anime_home::entities::ApiComment> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner =
            <Vec<(String, crate::anime_home::entities::ApiComment)>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();
    }
}

impl SseDecode for crate::anime_home::entities::ApiComment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_objId = <String>::sse_decode(deserializer);
        let mut var_content = <String>::sse_decode(deserializer);
        let mut var_senderIp = <String>::sse_decode(deserializer);
        let mut var_senderUid = <String>::sse_decode(deserializer);
        let mut var_isGoods = <String>::sse_decode(deserializer);
        let mut var_uploadImages = <String>::sse_decode(deserializer);
        let mut var_createTime = <String>::sse_decode(deserializer);
        let mut var_likeAmount = <String>::sse_decode(deserializer);
        let mut var_senderTerminal = <String>::sse_decode(deserializer);
        let mut var_originCommentId = <String>::sse_decode(deserializer);
        let mut var_nickname = <String>::sse_decode(deserializer);
        let mut var_userLevel = <String>::sse_decode(deserializer);
        let mut var_mPeriod = <String>::sse_decode(deserializer);
        let mut var_mCate = <String>::sse_decode(deserializer);
        let mut var_isFeeUser = <bool>::sse_decode(deserializer);
        let mut var_avatarUrl = <String>::sse_decode(deserializer);
        let mut var_sex = <String>::sse_decode(deserializer);
        let mut var_isLike = <bool>::sse_decode(deserializer);
        return crate::anime_home::entities::ApiComment {
            id: var_id,
            obj_id: var_objId,
            content: var_content,
            sender_ip: var_senderIp,
            sender_uid: var_senderUid,
            is_goods: var_isGoods,
            upload_images: var_uploadImages,
            create_time: var_createTime,
            like_amount: var_likeAmount,
            sender_terminal: var_senderTerminal,
            origin_comment_id: var_originCommentId,
            nickname: var_nickname,
            user_level: var_userLevel,
            m_period: var_mPeriod,
            m_cate: var_mCate,
            is_fee_user: var_isFeeUser,
            avatar_url: var_avatarUrl,
            sex: var_sex,
            is_like: var_isLike,
        };
    }
}

impl SseDecode for crate::anime_home::entities::ApiCommentResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_commentIds = <Vec<String>>::sse_decode(deserializer);
        let mut var_comments = <std::collections::HashMap<
            String,
            crate::anime_home::entities::ApiComment,
        >>::sse_decode(deserializer);
        let mut var_total = <i64>::sse_decode(deserializer);
        return crate::anime_home::entities::ApiCommentResponse {
            comment_ids: var_commentIds,
            comments: var_comments,
            total: var_total,
        };
    }
}

impl SseDecode for crate::anime_home::entities::Author {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_nickname = <String>::sse_decode(deserializer);
        let mut var_description = <String>::sse_decode(deserializer);
        let mut var_cover = <String>::sse_decode(deserializer);
        let mut var_data =
            <Vec<crate::anime_home::entities::ComicInAuthor>>::sse_decode(deserializer);
        return crate::anime_home::entities::Author {
            nickname: var_nickname,
            description: var_description,
            cover: var_cover,
            data: var_data,
        };
    }
}

impl SseDecode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode for crate::anime_home::entities::ComicCategory {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_tagId = <i32>::sse_decode(deserializer);
        let mut var_title = <String>::sse_decode(deserializer);
        let mut var_cover = <String>::sse_decode(deserializer);
        return crate::anime_home::entities::ComicCategory {
            tag_id: var_tagId,
            title: var_title,
            cover: var_cover,
        };
    }
}

impl SseDecode for crate::anime_home::proto::ComicChapter {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_title = <String>::sse_decode(deserializer);
        let mut var_data =
            <Vec<crate::anime_home::proto::ComicChapterInfo>>::sse_decode(deserializer);
        return crate::anime_home::proto::ComicChapter {
            title: var_title,
            data: var_data,
        };
    }
}

impl SseDecode for crate::anime_home::proto::ComicChapterDetail {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_chapterId = <i64>::sse_decode(deserializer);
        let mut var_comicId = <i64>::sse_decode(deserializer);
        let mut var_title = <String>::sse_decode(deserializer);
        let mut var_chapterOrder = <i32>::sse_decode(deserializer);
        let mut var_direction = <i32>::sse_decode(deserializer);
        let mut var_pageUrl = <Vec<String>>::sse_decode(deserializer);
        let mut var_picnum = <i32>::sse_decode(deserializer);
        let mut var_pageUrlHd = <Vec<String>>::sse_decode(deserializer);
        let mut var_commentCount = <i32>::sse_decode(deserializer);
        return crate::anime_home::proto::ComicChapterDetail {
            chapter_id: var_chapterId,
            comic_id: var_comicId,
            title: var_title,
            chapter_order: var_chapterOrder,
            direction: var_direction,
            page_url: var_pageUrl,
            picnum: var_picnum,
            page_url_hd: var_pageUrlHd,
            comment_count: var_commentCount,
        };
    }
}

impl SseDecode for crate::anime_home::proto::ComicChapterInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_chapterId = <i32>::sse_decode(deserializer);
        let mut var_chapterTitle = <String>::sse_decode(deserializer);
        let mut var_updateTime = <i64>::sse_decode(deserializer);
        let mut var_fileSize = <i32>::sse_decode(deserializer);
        let mut var_chapterOrder = <i32>::sse_decode(deserializer);
        return crate::anime_home::proto::ComicChapterInfo {
            chapter_id: var_chapterId,
            chapter_title: var_chapterTitle,
            update_time: var_updateTime,
            file_size: var_fileSize,
            chapter_order: var_chapterOrder,
        };
    }
}

impl SseDecode for crate::anime_home::proto::ComicDetail {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <i32>::sse_decode(deserializer);
        let mut var_title = <String>::sse_decode(deserializer);
        let mut var_direction = <i32>::sse_decode(deserializer);
        let mut var_isLong = <i32>::sse_decode(deserializer);
        let mut var_isAnimeHome = <i32>::sse_decode(deserializer);
        let mut var_cover = <String>::sse_decode(deserializer);
        let mut var_description = <String>::sse_decode(deserializer);
        let mut var_lastUpdateTime = <i64>::sse_decode(deserializer);
        let mut var_lastUpdateChapterName = <String>::sse_decode(deserializer);
        let mut var_copyright = <i32>::sse_decode(deserializer);
        let mut var_firstLetter = <String>::sse_decode(deserializer);
        let mut var_comicPy = <String>::sse_decode(deserializer);
        let mut var_hidden = <i32>::sse_decode(deserializer);
        let mut var_hotNum = <i32>::sse_decode(deserializer);
        let mut var_hitNum = <i32>::sse_decode(deserializer);
        let mut var_uid = <i32>::sse_decode(deserializer);
        let mut var_isLock = <i32>::sse_decode(deserializer);
        let mut var_lastUpdateChapterId = <i32>::sse_decode(deserializer);
        let mut var_types = <Vec<crate::anime_home::proto::Item>>::sse_decode(deserializer);
        let mut var_status = <Vec<crate::anime_home::proto::Item>>::sse_decode(deserializer);
        let mut var_authors = <Vec<crate::anime_home::proto::Item>>::sse_decode(deserializer);
        let mut var_subscribeNum = <i32>::sse_decode(deserializer);
        let mut var_chapters =
            <Vec<crate::anime_home::proto::ComicChapter>>::sse_decode(deserializer);
        let mut var_isNeedLogin = <i32>::sse_decode(deserializer);
        let mut var_isHideChapter = <i32>::sse_decode(deserializer);
        return crate::anime_home::proto::ComicDetail {
            id: var_id,
            title: var_title,
            direction: var_direction,
            is_long: var_isLong,
            is_anime_home: var_isAnimeHome,
            cover: var_cover,
            description: var_description,
            last_update_time: var_lastUpdateTime,
            last_update_chapter_name: var_lastUpdateChapterName,
            copyright: var_copyright,
            first_letter: var_firstLetter,
            comic_py: var_comicPy,
            hidden: var_hidden,
            hot_num: var_hotNum,
            hit_num: var_hitNum,
            uid: var_uid,
            is_lock: var_isLock,
            last_update_chapter_id: var_lastUpdateChapterId,
            types: var_types,
            status: var_status,
            authors: var_authors,
            subscribe_num: var_subscribeNum,
            chapters: var_chapters,
            is_need_login: var_isNeedLogin,
            is_hide_chapter: var_isHideChapter,
        };
    }
}

impl SseDecode for crate::anime_home::entities::ComicFilter {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_title = <String>::sse_decode(deserializer);
        let mut var_items =
            <Vec<crate::anime_home::entities::ComicFilterItem>>::sse_decode(deserializer);
        return crate::anime_home::entities::ComicFilter {
            title: var_title,
            items: var_items,
        };
    }
}

impl SseDecode for crate::anime_home::entities::ComicFilterItem {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_tagId = <i64>::sse_decode(deserializer);
        let mut var_tagName = <String>::sse_decode(deserializer);
        return crate::anime_home::entities::ComicFilterItem {
            tag_id: var_tagId,
            tag_name: var_tagName,
        };
    }
}

impl SseDecode for crate::anime_home::entities::ComicInAuthor {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <i64>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_cover = <String>::sse_decode(deserializer);
        let mut var_status = <String>::sse_decode(deserializer);
        return crate::anime_home::entities::ComicInAuthor {
            id: var_id,
            name: var_name,
            cover: var_cover,
            status: var_status,
        };
    }
}

impl SseDecode for crate::anime_home::entities::ComicInFilter {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <i64>::sse_decode(deserializer);
        let mut var_title = <String>::sse_decode(deserializer);
        let mut var_authors = <String>::sse_decode(deserializer);
        let mut var_status = <String>::sse_decode(deserializer);
        let mut var_cover = <String>::sse_decode(deserializer);
        let mut var_types = <String>::sse_decode(deserializer);
        let mut var_lastUpdateTime = <i64>::sse_decode(deserializer);
        let mut var_num = <i64>::sse_decode(deserializer);
        return crate::anime_home::entities::ComicInFilter {
            id: var_id,
            title: var_title,
            authors: var_authors,
            status: var_status,
            cover: var_cover,
            types: var_types,
            last_update_time: var_lastUpdateTime,
            num: var_num,
        };
    }
}

impl SseDecode for crate::anime_home::entities::ComicInSearch {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_biz = <String>::sse_decode(deserializer);
        let mut var_addtime = <i64>::sse_decode(deserializer);
        let mut var_authors = <String>::sse_decode(deserializer);
        let mut var_copyright = <i64>::sse_decode(deserializer);
        let mut var_cover = <String>::sse_decode(deserializer);
        let mut var_hidden = <i64>::sse_decode(deserializer);
        let mut var_hotHits = <i64>::sse_decode(deserializer);
        let mut var_lastName = <String>::sse_decode(deserializer);
        let mut var_status = <i64>::sse_decode(deserializer);
        let mut var_title = <String>::sse_decode(deserializer);
        let mut var_types = <String>::sse_decode(deserializer);
        let mut var_id = <i64>::sse_decode(deserializer);
        return crate::anime_home::entities::ComicInSearch {
            biz: var_biz,
            addtime: var_addtime,
            authors: var_authors,
            copyright: var_copyright,
            cover: var_cover,
            hidden: var_hidden,
            hot_hits: var_hotHits,
            last_name: var_lastName,
            status: var_status,
            title: var_title,
            types: var_types,
            id: var_id,
        };
    }
}

impl SseDecode for crate::anime_home::proto::ComicRankListItem {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <i32>::sse_decode(deserializer);
        let mut var_title = <String>::sse_decode(deserializer);
        let mut var_authors = <String>::sse_decode(deserializer);
        let mut var_status = <String>::sse_decode(deserializer);
        let mut var_cover = <String>::sse_decode(deserializer);
        let mut var_types = <String>::sse_decode(deserializer);
        let mut var_lastUpdateTime = <i64>::sse_decode(deserializer);
        let mut var_lastUpdateChapterName = <String>::sse_decode(deserializer);
        let mut var_comicPy = <String>::sse_decode(deserializer);
        let mut var_num = <i32>::sse_decode(deserializer);
        let mut var_tagId = <i32>::sse_decode(deserializer);
        let mut var_chapterName = <String>::sse_decode(deserializer);
        let mut var_chapterId = <i32>::sse_decode(deserializer);
        return crate::anime_home::proto::ComicRankListItem {
            id: var_id,
            title: var_title,
            authors: var_authors,
            status: var_status,
            cover: var_cover,
            types: var_types,
            last_update_time: var_lastUpdateTime,
            last_update_chapter_name: var_lastUpdateChapterName,
            comic_py: var_comicPy,
            num: var_num,
            tag_id: var_tagId,
            chapter_name: var_chapterName,
            chapter_id: var_chapterId,
        };
    }
}

impl SseDecode for crate::anime_home::proto::ComicUpdateListItem {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <i32>::sse_decode(deserializer);
        let mut var_title = <String>::sse_decode(deserializer);
        let mut var_isLong = <bool>::sse_decode(deserializer);
        let mut var_authors = <String>::sse_decode(deserializer);
        let mut var_types = <String>::sse_decode(deserializer);
        let mut var_cover = <String>::sse_decode(deserializer);
        let mut var_status = <String>::sse_decode(deserializer);
        let mut var_lastUpdateChapterName = <String>::sse_decode(deserializer);
        let mut var_lastUpdateChapterId = <i32>::sse_decode(deserializer);
        let mut var_lastUpdateTime = <i64>::sse_decode(deserializer);
        return crate::anime_home::proto::ComicUpdateListItem {
            id: var_id,
            title: var_title,
            is_long: var_isLong,
            authors: var_authors,
            types: var_types,
            cover: var_cover,
            status: var_status,
            last_update_chapter_name: var_lastUpdateChapterName,
            last_update_chapter_id: var_lastUpdateChapterId,
            last_update_time: var_lastUpdateTime,
        };
    }
}

impl SseDecode for crate::api::bridge::ComicViewLog {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_comicId = <i32>::sse_decode(deserializer);
        let mut var_comicTitle = <String>::sse_decode(deserializer);
        let mut var_comicAuthors = <String>::sse_decode(deserializer);
        let mut var_comicStatus = <String>::sse_decode(deserializer);
        let mut var_comicCover = <String>::sse_decode(deserializer);
        let mut var_comicTypes = <String>::sse_decode(deserializer);
        let mut var_comicLastUpdateTime = <i64>::sse_decode(deserializer);
        let mut var_comicLastUpdateChapterName = <String>::sse_decode(deserializer);
        let mut var_chapterId = <i32>::sse_decode(deserializer);
        let mut var_chapterTitle = <String>::sse_decode(deserializer);
        let mut var_chapterOrder = <i32>::sse_decode(deserializer);
        let mut var_pageRank = <i32>::sse_decode(deserializer);
        let mut var_viewTime = <i64>::sse_decode(deserializer);
        return crate::api::bridge::ComicViewLog {
            comic_id: var_comicId,
            comic_title: var_comicTitle,
            comic_authors: var_comicAuthors,
            comic_status: var_comicStatus,
            comic_cover: var_comicCover,
            comic_types: var_comicTypes,
            comic_last_update_time: var_comicLastUpdateTime,
            comic_last_update_chapter_name: var_comicLastUpdateChapterName,
            chapter_id: var_chapterId,
            chapter_title: var_chapterTitle,
            chapter_order: var_chapterOrder,
            page_rank: var_pageRank,
            view_time: var_viewTime,
        };
    }
}

impl SseDecode for crate::anime_home::entities::Comment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <i64>::sse_decode(deserializer);
        let mut var_isPassed = <i64>::sse_decode(deserializer);
        let mut var_topStatus = <i64>::sse_decode(deserializer);
        let mut var_isGoods = <i64>::sse_decode(deserializer);
        let mut var_uploadImages = <String>::sse_decode(deserializer);
        let mut var_objId = <i64>::sse_decode(deserializer);
        let mut var_content = <String>::sse_decode(deserializer);
        let mut var_senderUid = <i64>::sse_decode(deserializer);
        let mut var_likeAmount = <i64>::sse_decode(deserializer);
        let mut var_createTime = <i64>::sse_decode(deserializer);
        let mut var_toUid = <i64>::sse_decode(deserializer);
        let mut var_toCommentId = <i64>::sse_decode(deserializer);
        let mut var_originCommentId = <i64>::sse_decode(deserializer);
        let mut var_replyAmount = <i64>::sse_decode(deserializer);
        let mut var_hotCommentAmount = <i64>::sse_decode(deserializer);
        let mut var_cover = <String>::sse_decode(deserializer);
        let mut var_nickname = <String>::sse_decode(deserializer);
        let mut var_avatarUrl = <String>::sse_decode(deserializer);
        let mut var_sex = <i64>::sse_decode(deserializer);
        let mut var_masterCommentNum = <i64>::sse_decode(deserializer);
        let mut var_masterComment =
            <Vec<crate::anime_home::entities::MasterComment>>::sse_decode(deserializer);
        return crate::anime_home::entities::Comment {
            id: var_id,
            is_passed: var_isPassed,
            top_status: var_topStatus,
            is_goods: var_isGoods,
            upload_images: var_uploadImages,
            obj_id: var_objId,
            content: var_content,
            sender_uid: var_senderUid,
            like_amount: var_likeAmount,
            create_time: var_createTime,
            to_uid: var_toUid,
            to_comment_id: var_toCommentId,
            origin_comment_id: var_originCommentId,
            reply_amount: var_replyAmount,
            hot_comment_amount: var_hotCommentAmount,
            cover: var_cover,
            nickname: var_nickname,
            avatar_url: var_avatarUrl,
            sex: var_sex,
            master_comment_num: var_masterCommentNum,
            master_comment: var_masterComment,
        };
    }
}

impl SseDecode for crate::anime_home::entities::DayList {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <i64>::sse_decode(deserializer);
        let mut var_title = <String>::sse_decode(deserializer);
        let mut var_icon = <String>::sse_decode(deserializer);
        let mut var_iconChecked = <String>::sse_decode(deserializer);
        let mut var_typeId = <i64>::sse_decode(deserializer);
        let mut var_times = <i64>::sse_decode(deserializer);
        let mut var_nums = <i64>::sse_decode(deserializer);
        let mut var_creditsNums = <i64>::sse_decode(deserializer);
        return crate::anime_home::entities::DayList {
            id: var_id,
            title: var_title,
            icon: var_icon,
            icon_checked: var_iconChecked,
            type_id: var_typeId,
            times: var_times,
            nums: var_nums,
            credits_nums: var_creditsNums,
        };
    }
}

impl SseDecode for crate::anime_home::entities::DaySignTask {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_currentDay = <i64>::sse_decode(deserializer);
        let mut var_status = <i64>::sse_decode(deserializer);
        let mut var_doubleStatus = <i64>::sse_decode(deserializer);
        let mut var_dayList = <Vec<crate::anime_home::entities::DayList>>::sse_decode(deserializer);
        return crate::anime_home::entities::DaySignTask {
            current_day: var_currentDay,
            status: var_status,
            double_status: var_doubleStatus,
            day_list: var_dayList,
        };
    }
}

impl SseDecode for crate::api::bridge::DownloadComic {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <i32>::sse_decode(deserializer);
        let mut var_title = <String>::sse_decode(deserializer);
        let mut var_authors = <String>::sse_decode(deserializer);
        let mut var_types = <String>::sse_decode(deserializer);
        let mut var_status = <String>::sse_decode(deserializer);
        let mut var_direction = <i32>::sse_decode(deserializer);
        let mut var_isLong = <i32>::sse_decode(deserializer);
        let mut var_isAnimeHome = <i32>::sse_decode(deserializer);
        let mut var_cover = <String>::sse_decode(deserializer);
        let mut var_description = <String>::sse_decode(deserializer);
        let mut var_copyright = <i32>::sse_decode(deserializer);
        let mut var_firstLetter = <String>::sse_decode(deserializer);
        let mut var_comicPy = <String>::sse_decode(deserializer);
        let mut var_coverDownloadStatus = <i32>::sse_decode(deserializer);
        let mut var_coverFormat = <String>::sse_decode(deserializer);
        let mut var_coverWidth = <u32>::sse_decode(deserializer);
        let mut var_coverHeight = <u32>::sse_decode(deserializer);
        let mut var_downloadStatus = <i32>::sse_decode(deserializer);
        let mut var_imageCount = <i32>::sse_decode(deserializer);
        let mut var_imageCountDownload = <i32>::sse_decode(deserializer);
        return crate::api::bridge::DownloadComic {
            id: var_id,
            title: var_title,
            authors: var_authors,
            types: var_types,
            status: var_status,
            direction: var_direction,
            is_long: var_isLong,
            is_anime_home: var_isAnimeHome,
            cover: var_cover,
            description: var_description,
            copyright: var_copyright,
            first_letter: var_firstLetter,
            comic_py: var_comicPy,
            cover_download_status: var_coverDownloadStatus,
            cover_format: var_coverFormat,
            cover_width: var_coverWidth,
            cover_height: var_coverHeight,
            download_status: var_downloadStatus,
            image_count: var_imageCount,
            image_count_download: var_imageCountDownload,
        };
    }
}

impl SseDecode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for i64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::anime_home::proto::Item {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <i32>::sse_decode(deserializer);
        let mut var_title = <String>::sse_decode(deserializer);
        return crate::anime_home::proto::Item {
            id: var_id,
            title: var_title,
        };
    }
}

impl SseDecode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<String>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::anime_home::entities::ComicCategory> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::anime_home::entities::ComicCategory>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::anime_home::proto::ComicChapter> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::anime_home::proto::ComicChapter>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::anime_home::proto::ComicChapterInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::anime_home::proto::ComicChapterInfo>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::anime_home::entities::ComicFilter> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::anime_home::entities::ComicFilter>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::anime_home::entities::ComicFilterItem> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::anime_home::entities::ComicFilterItem>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::anime_home::entities::ComicInAuthor> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::anime_home::entities::ComicInAuthor>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::anime_home::entities::ComicInFilter> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::anime_home::entities::ComicInFilter>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::anime_home::entities::ComicInSearch> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::anime_home::entities::ComicInSearch>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::anime_home::proto::ComicRankListItem> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::anime_home::proto::ComicRankListItem>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::anime_home::proto::ComicUpdateListItem> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::anime_home::proto::ComicUpdateListItem>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::bridge::ComicViewLog> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::bridge::ComicViewLog>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::anime_home::entities::Comment> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::anime_home::entities::Comment>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::anime_home::entities::DayList> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::anime_home::entities::DayList>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::bridge::DownloadComic> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::bridge::DownloadComic>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::anime_home::proto::Item> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::anime_home::proto::Item>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::anime_home::entities::MasterComment> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::anime_home::entities::MasterComment>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::anime_home::entities::NewsCategory> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::anime_home::entities::NewsCategory>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::anime_home::proto::NewsListItem> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::anime_home::proto::NewsListItem>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::anime_home::entities::NovelCategory> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::anime_home::entities::NovelCategory>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::anime_home::proto::NovelChapter> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::anime_home::proto::NovelChapter>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::anime_home::entities::NovelInFilter> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::anime_home::entities::NovelInFilter>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::anime_home::entities::NovelInSearch> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::anime_home::entities::NovelInSearch>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::bridge::NovelViewLog> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::bridge::NovelViewLog>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::anime_home::proto::NovelVolume> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::anime_home::proto::NovelVolume>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::anime_home::proto::NovelVolumeInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::anime_home::proto::NovelVolumeInfo>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<i32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<i32>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(String, crate::anime_home::entities::ApiComment)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <(String, crate::anime_home::entities::ApiComment)>::sse_decode(deserializer),
            );
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::anime_home::entities::Subscribed> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::anime_home::entities::Subscribed>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::anime_home::entities::Task> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::anime_home::entities::Task>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::anime_home::entities::TaskList> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::anime_home::entities::TaskList>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for crate::api::bridge::LocalImage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_absPath = <String>::sse_decode(deserializer);
        let mut var_localPath = <String>::sse_decode(deserializer);
        let mut var_imageFormat = <String>::sse_decode(deserializer);
        let mut var_imageWidth = <u32>::sse_decode(deserializer);
        let mut var_imageHeight = <u32>::sse_decode(deserializer);
        return crate::api::bridge::LocalImage {
            abs_path: var_absPath,
            local_path: var_localPath,
            image_format: var_imageFormat,
            image_width: var_imageWidth,
            image_height: var_imageHeight,
        };
    }
}

impl SseDecode for crate::anime_home::entities::LoginData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_uid = <String>::sse_decode(deserializer);
        let mut var_nickname = <String>::sse_decode(deserializer);
        let mut var_dmzjToken = <String>::sse_decode(deserializer);
        let mut var_photo = <String>::sse_decode(deserializer);
        let mut var_bindPhone = <String>::sse_decode(deserializer);
        let mut var_email = <String>::sse_decode(deserializer);
        let mut var_passwd = <String>::sse_decode(deserializer);
        return crate::anime_home::entities::LoginData {
            uid: var_uid,
            nickname: var_nickname,
            dmzj_token: var_dmzjToken,
            photo: var_photo,
            bind_phone: var_bindPhone,
            email: var_email,
            passwd: var_passwd,
        };
    }
}

impl SseDecode for crate::api::bridge::LoginInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_status = <i32>::sse_decode(deserializer);
        let mut var_message = <String>::sse_decode(deserializer);
        let mut var_data =
            <Option<crate::anime_home::entities::LoginData>>::sse_decode(deserializer);
        return crate::api::bridge::LoginInfo {
            status: var_status,
            message: var_message,
            data: var_data,
        };
    }
}

impl SseDecode for crate::anime_home::entities::MasterComment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <i64>::sse_decode(deserializer);
        let mut var_isPassed = <i64>::sse_decode(deserializer);
        let mut var_topStatus = <i64>::sse_decode(deserializer);
        let mut var_isGoods = <i64>::sse_decode(deserializer);
        let mut var_uploadImages = <String>::sse_decode(deserializer);
        let mut var_objId = <i64>::sse_decode(deserializer);
        let mut var_content = <String>::sse_decode(deserializer);
        let mut var_senderUid = <i64>::sse_decode(deserializer);
        let mut var_likeAmount = <i64>::sse_decode(deserializer);
        let mut var_createTime = <i64>::sse_decode(deserializer);
        let mut var_toUid = <i64>::sse_decode(deserializer);
        let mut var_toCommentId = <i64>::sse_decode(deserializer);
        let mut var_originCommentId = <i64>::sse_decode(deserializer);
        let mut var_replyAmount = <i64>::sse_decode(deserializer);
        let mut var_cover = <String>::sse_decode(deserializer);
        let mut var_nickname = <String>::sse_decode(deserializer);
        let mut var_hotCommentAmount = <i64>::sse_decode(deserializer);
        let mut var_sex = <i64>::sse_decode(deserializer);
        return crate::anime_home::entities::MasterComment {
            id: var_id,
            is_passed: var_isPassed,
            top_status: var_topStatus,
            is_goods: var_isGoods,
            upload_images: var_uploadImages,
            obj_id: var_objId,
            content: var_content,
            sender_uid: var_senderUid,
            like_amount: var_likeAmount,
            create_time: var_createTime,
            to_uid: var_toUid,
            to_comment_id: var_toCommentId,
            origin_comment_id: var_originCommentId,
            reply_amount: var_replyAmount,
            cover: var_cover,
            nickname: var_nickname,
            hot_comment_amount: var_hotCommentAmount,
            sex: var_sex,
        };
    }
}

impl SseDecode for crate::anime_home::entities::NewsCategory {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_tagId = <i64>::sse_decode(deserializer);
        let mut var_tagName = <String>::sse_decode(deserializer);
        return crate::anime_home::entities::NewsCategory {
            tag_id: var_tagId,
            tag_name: var_tagName,
        };
    }
}

impl SseDecode for crate::anime_home::proto::NewsListItem {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <i32>::sse_decode(deserializer);
        let mut var_title = <String>::sse_decode(deserializer);
        let mut var_fromName = <String>::sse_decode(deserializer);
        let mut var_fromUrl = <String>::sse_decode(deserializer);
        let mut var_createTime = <i64>::sse_decode(deserializer);
        let mut var_isForeign = <i32>::sse_decode(deserializer);
        let mut var_foreignUrl = <String>::sse_decode(deserializer);
        let mut var_intro = <String>::sse_decode(deserializer);
        let mut var_authorId = <i32>::sse_decode(deserializer);
        let mut var_status = <i32>::sse_decode(deserializer);
        let mut var_rowPicUrl = <String>::sse_decode(deserializer);
        let mut var_colPicUrl = <String>::sse_decode(deserializer);
        let mut var_qChatShow = <i32>::sse_decode(deserializer);
        let mut var_pageUrl = <String>::sse_decode(deserializer);
        let mut var_commentAmount = <i32>::sse_decode(deserializer);
        let mut var_authorUid = <i32>::sse_decode(deserializer);
        let mut var_cover = <String>::sse_decode(deserializer);
        let mut var_nickname = <String>::sse_decode(deserializer);
        let mut var_moodAmount = <i32>::sse_decode(deserializer);
        return crate::anime_home::proto::NewsListItem {
            id: var_id,
            title: var_title,
            from_name: var_fromName,
            from_url: var_fromUrl,
            create_time: var_createTime,
            is_foreign: var_isForeign,
            foreign_url: var_foreignUrl,
            intro: var_intro,
            author_id: var_authorId,
            status: var_status,
            row_pic_url: var_rowPicUrl,
            col_pic_url: var_colPicUrl,
            q_chat_show: var_qChatShow,
            page_url: var_pageUrl,
            comment_amount: var_commentAmount,
            author_uid: var_authorUid,
            cover: var_cover,
            nickname: var_nickname,
            mood_amount: var_moodAmount,
        };
    }
}

impl SseDecode for crate::anime_home::entities::NovelCategory {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_tagId = <i64>::sse_decode(deserializer);
        let mut var_title = <String>::sse_decode(deserializer);
        let mut var_cover = <String>::sse_decode(deserializer);
        return crate::anime_home::entities::NovelCategory {
            tag_id: var_tagId,
            title: var_title,
            cover: var_cover,
        };
    }
}

impl SseDecode for crate::anime_home::proto::NovelChapter {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_chapterId = <i32>::sse_decode(deserializer);
        let mut var_chapterName = <String>::sse_decode(deserializer);
        let mut var_chapterOrder = <i32>::sse_decode(deserializer);
        return crate::anime_home::proto::NovelChapter {
            chapter_id: var_chapterId,
            chapter_name: var_chapterName,
            chapter_order: var_chapterOrder,
        };
    }
}

impl SseDecode for crate::anime_home::proto::NovelDetail {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <i32>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_zone = <String>::sse_decode(deserializer);
        let mut var_status = <String>::sse_decode(deserializer);
        let mut var_lastUpdateVolumeName = <String>::sse_decode(deserializer);
        let mut var_lastUpdateChapterName = <String>::sse_decode(deserializer);
        let mut var_lastUpdateVolumeId = <i32>::sse_decode(deserializer);
        let mut var_lastUpdateChapterId = <i32>::sse_decode(deserializer);
        let mut var_lastUpdateTime = <i64>::sse_decode(deserializer);
        let mut var_cover = <String>::sse_decode(deserializer);
        let mut var_hotHits = <i32>::sse_decode(deserializer);
        let mut var_introduction = <String>::sse_decode(deserializer);
        let mut var_types = <Vec<String>>::sse_decode(deserializer);
        let mut var_authors = <String>::sse_decode(deserializer);
        let mut var_firstLetter = <String>::sse_decode(deserializer);
        let mut var_subscribeNum = <i32>::sse_decode(deserializer);
        let mut var_redisUpdateTime = <i64>::sse_decode(deserializer);
        let mut var_volumes =
            <Vec<crate::anime_home::proto::NovelVolumeInfo>>::sse_decode(deserializer);
        return crate::anime_home::proto::NovelDetail {
            id: var_id,
            name: var_name,
            zone: var_zone,
            status: var_status,
            last_update_volume_name: var_lastUpdateVolumeName,
            last_update_chapter_name: var_lastUpdateChapterName,
            last_update_volume_id: var_lastUpdateVolumeId,
            last_update_chapter_id: var_lastUpdateChapterId,
            last_update_time: var_lastUpdateTime,
            cover: var_cover,
            hot_hits: var_hotHits,
            introduction: var_introduction,
            types: var_types,
            authors: var_authors,
            first_letter: var_firstLetter,
            subscribe_num: var_subscribeNum,
            redis_update_time: var_redisUpdateTime,
            volumes: var_volumes,
        };
    }
}

impl SseDecode for crate::anime_home::entities::NovelInFilter {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_cover = <String>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_authors = <String>::sse_decode(deserializer);
        let mut var_id = <i64>::sse_decode(deserializer);
        return crate::anime_home::entities::NovelInFilter {
            cover: var_cover,
            name: var_name,
            authors: var_authors,
            id: var_id,
        };
    }
}

impl SseDecode for crate::anime_home::entities::NovelInSearch {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_biz = <String>::sse_decode(deserializer);
        let mut var_addtime = <i64>::sse_decode(deserializer);
        let mut var_authors = <String>::sse_decode(deserializer);
        let mut var_copyright = <i64>::sse_decode(deserializer);
        let mut var_cover = <String>::sse_decode(deserializer);
        let mut var_hidden = <i64>::sse_decode(deserializer);
        let mut var_hotHits = <i64>::sse_decode(deserializer);
        let mut var_lastName = <String>::sse_decode(deserializer);
        let mut var_status = <i64>::sse_decode(deserializer);
        let mut var_title = <String>::sse_decode(deserializer);
        let mut var_types = <String>::sse_decode(deserializer);
        let mut var_id = <i64>::sse_decode(deserializer);
        return crate::anime_home::entities::NovelInSearch {
            biz: var_biz,
            addtime: var_addtime,
            authors: var_authors,
            copyright: var_copyright,
            cover: var_cover,
            hidden: var_hidden,
            hot_hits: var_hotHits,
            last_name: var_lastName,
            status: var_status,
            title: var_title,
            types: var_types,
            id: var_id,
        };
    }
}

impl SseDecode for crate::api::bridge::NovelViewLog {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_novelId = <i32>::sse_decode(deserializer);
        let mut var_novelTitle = <String>::sse_decode(deserializer);
        let mut var_novelZone = <String>::sse_decode(deserializer);
        let mut var_novelStatus = <String>::sse_decode(deserializer);
        let mut var_novelLastUpdateVolumeName = <String>::sse_decode(deserializer);
        let mut var_novelLastUpdateChapterName = <String>::sse_decode(deserializer);
        let mut var_novelLastUpdateVolumeId = <i32>::sse_decode(deserializer);
        let mut var_novelLastUpdateChapterId = <i32>::sse_decode(deserializer);
        let mut var_novelLastUpdateTime = <i64>::sse_decode(deserializer);
        let mut var_novelCover = <String>::sse_decode(deserializer);
        let mut var_novelHotHits = <i32>::sse_decode(deserializer);
        let mut var_novelIntroduction = <String>::sse_decode(deserializer);
        let mut var_novelTypes = <String>::sse_decode(deserializer);
        let mut var_novelAuthors = <String>::sse_decode(deserializer);
        let mut var_novelFirstLetter = <String>::sse_decode(deserializer);
        let mut var_novelSubscribeNum = <i32>::sse_decode(deserializer);
        let mut var_novelRedisUpdateTime = <i64>::sse_decode(deserializer);
        let mut var_volumeId = <i32>::sse_decode(deserializer);
        let mut var_volumeTitle = <String>::sse_decode(deserializer);
        let mut var_volumeOrder = <i32>::sse_decode(deserializer);
        let mut var_chapterId = <i32>::sse_decode(deserializer);
        let mut var_chapterTitle = <String>::sse_decode(deserializer);
        let mut var_chapterOrder = <i32>::sse_decode(deserializer);
        let mut var_progress = <i64>::sse_decode(deserializer);
        let mut var_viewTime = <i64>::sse_decode(deserializer);
        return crate::api::bridge::NovelViewLog {
            novel_id: var_novelId,
            novel_title: var_novelTitle,
            novel_zone: var_novelZone,
            novel_status: var_novelStatus,
            novel_last_update_volume_name: var_novelLastUpdateVolumeName,
            novel_last_update_chapter_name: var_novelLastUpdateChapterName,
            novel_last_update_volume_id: var_novelLastUpdateVolumeId,
            novel_last_update_chapter_id: var_novelLastUpdateChapterId,
            novel_last_update_time: var_novelLastUpdateTime,
            novel_cover: var_novelCover,
            novel_hot_hits: var_novelHotHits,
            novel_introduction: var_novelIntroduction,
            novel_types: var_novelTypes,
            novel_authors: var_novelAuthors,
            novel_first_letter: var_novelFirstLetter,
            novel_subscribe_num: var_novelSubscribeNum,
            novel_redis_update_time: var_novelRedisUpdateTime,
            volume_id: var_volumeId,
            volume_title: var_volumeTitle,
            volume_order: var_volumeOrder,
            chapter_id: var_chapterId,
            chapter_title: var_chapterTitle,
            chapter_order: var_chapterOrder,
            progress: var_progress,
            view_time: var_viewTime,
        };
    }
}

impl SseDecode for crate::anime_home::proto::NovelVolume {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <i32>::sse_decode(deserializer);
        let mut var_title = <String>::sse_decode(deserializer);
        let mut var_rank = <i32>::sse_decode(deserializer);
        let mut var_chapters =
            <Vec<crate::anime_home::proto::NovelChapter>>::sse_decode(deserializer);
        return crate::anime_home::proto::NovelVolume {
            id: var_id,
            title: var_title,
            rank: var_rank,
            chapters: var_chapters,
        };
    }
}

impl SseDecode for crate::anime_home::proto::NovelVolumeInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <i32>::sse_decode(deserializer);
        let mut var_novelId = <i32>::sse_decode(deserializer);
        let mut var_title = <String>::sse_decode(deserializer);
        let mut var_rank = <i32>::sse_decode(deserializer);
        let mut var_addTime = <i64>::sse_decode(deserializer);
        let mut var_chaptersCount = <i32>::sse_decode(deserializer);
        return crate::anime_home::proto::NovelVolumeInfo {
            id: var_id,
            novel_id: var_novelId,
            title: var_title,
            rank: var_rank,
            add_time: var_addTime,
            chapters_count: var_chaptersCount,
        };
    }
}

impl SseDecode for Option<crate::api::bridge::ComicViewLog> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::bridge::ComicViewLog>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<i32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<i32>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::anime_home::entities::LoginData> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::anime_home::entities::LoginData>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::bridge::NovelViewLog> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::bridge::NovelViewLog>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for (String, crate::anime_home::entities::ApiComment) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <String>::sse_decode(deserializer);
        let mut var_field1 = <crate::anime_home::entities::ApiComment>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for crate::anime_home::entities::Subscribed {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_subUpdate = <String>::sse_decode(deserializer);
        let mut var_subImg = <String>::sse_decode(deserializer);
        let mut var_subUptime = <i64>::sse_decode(deserializer);
        let mut var_subFirstLetter = <String>::sse_decode(deserializer);
        let mut var_subReaded = <i64>::sse_decode(deserializer);
        let mut var_id = <i64>::sse_decode(deserializer);
        let mut var_status = <String>::sse_decode(deserializer);
        return crate::anime_home::entities::Subscribed {
            name: var_name,
            sub_update: var_subUpdate,
            sub_img: var_subImg,
            sub_uptime: var_subUptime,
            sub_first_letter: var_subFirstLetter,
            sub_readed: var_subReaded,
            id: var_id,
            status: var_status,
        };
    }
}

impl SseDecode for crate::anime_home::entities::SummationsTask {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_signCount = <i64>::sse_decode(deserializer);
        let mut var_maxSignCount = <i64>::sse_decode(deserializer);
        let mut var_taskList =
            <Vec<crate::anime_home::entities::TaskList>>::sse_decode(deserializer);
        return crate::anime_home::entities::SummationsTask {
            sign_count: var_signCount,
            max_sign_count: var_maxSignCount,
            task_list: var_taskList,
        };
    }
}

impl SseDecode for crate::anime_home::entities::Task {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <i64>::sse_decode(deserializer);
        let mut var_title = <String>::sse_decode(deserializer);
        let mut var_con = <String>::sse_decode(deserializer);
        let mut var_icon = <String>::sse_decode(deserializer);
        let mut var_times = <i64>::sse_decode(deserializer);
        let mut var_nums = <i64>::sse_decode(deserializer);
        let mut var_source = <i64>::sse_decode(deserializer);
        let mut var_typeId = <i64>::sse_decode(deserializer);
        let mut var_url = <String>::sse_decode(deserializer);
        let mut var_btn = <String>::sse_decode(deserializer);
        let mut var_status = <i64>::sse_decode(deserializer);
        let mut var_progress = <i64>::sse_decode(deserializer);
        return crate::anime_home::entities::Task {
            id: var_id,
            title: var_title,
            con: var_con,
            icon: var_icon,
            times: var_times,
            nums: var_nums,
            source: var_source,
            type_id: var_typeId,
            url: var_url,
            btn: var_btn,
            status: var_status,
            progress: var_progress,
        };
    }
}

impl SseDecode for crate::anime_home::entities::TaskIndex {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_newPersonTask =
            <Vec<crate::anime_home::entities::Task>>::sse_decode(deserializer);
        let mut var_dayTask = <Vec<crate::anime_home::entities::Task>>::sse_decode(deserializer);
        let mut var_weekTask = <Vec<crate::anime_home::entities::Task>>::sse_decode(deserializer);
        let mut var_summationsTask =
            <crate::anime_home::entities::SummationsTask>::sse_decode(deserializer);
        let mut var_daySignTask =
            <crate::anime_home::entities::DaySignTask>::sse_decode(deserializer);
        let mut var_creditsNums = <i64>::sse_decode(deserializer);
        let mut var_silverNums = <i64>::sse_decode(deserializer);
        let mut var_starsNums = <i64>::sse_decode(deserializer);
        return crate::anime_home::entities::TaskIndex {
            new_person_task: var_newPersonTask,
            day_task: var_dayTask,
            week_task: var_weekTask,
            summations_task: var_summationsTask,
            day_sign_task: var_daySignTask,
            credits_nums: var_creditsNums,
            silver_nums: var_silverNums,
            stars_nums: var_starsNums,
        };
    }
}

impl SseDecode for crate::anime_home::entities::TaskList {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <i64>::sse_decode(deserializer);
        let mut var_title = <String>::sse_decode(deserializer);
        let mut var_con = <String>::sse_decode(deserializer);
        let mut var_icon = <String>::sse_decode(deserializer);
        let mut var_times = <i64>::sse_decode(deserializer);
        let mut var_nums = <i64>::sse_decode(deserializer);
        let mut var_source = <i64>::sse_decode(deserializer);
        let mut var_typeId = <i64>::sse_decode(deserializer);
        let mut var_url = <String>::sse_decode(deserializer);
        let mut var_btn = <String>::sse_decode(deserializer);
        let mut var_status = <i64>::sse_decode(deserializer);
        let mut var_progress = <i64>::sse_decode(deserializer);
        let mut var_iconChecked = <String>::sse_decode(deserializer);
        return crate::anime_home::entities::TaskList {
            id: var_id,
            title: var_title,
            con: var_con,
            icon: var_icon,
            times: var_times,
            nums: var_nums,
            source: var_source,
            type_id: var_typeId,
            url: var_url,
            btn: var_btn,
            status: var_status,
            progress: var_progress,
            icon_checked: var_iconChecked,
        };
    }
}

impl SseDecode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap()
    }
}

impl SseDecode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
}

fn pde_ffi_dispatcher_primary_impl(
    func_id: i32,
    port: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        1 => wire__crate__api__bridge__all_downloads_impl(port, ptr, rust_vec_len, data_len),
        2 => wire__crate__api__bridge__author_impl(port, ptr, rust_vec_len, data_len),
        3 => wire__crate__api__bridge__auto_clean_impl(port, ptr, rust_vec_len, data_len),
        4 => wire__crate__api__bridge__comic_categories_impl(port, ptr, rust_vec_len, data_len),
        5 => wire__crate__api__bridge__comic_chapter_detail_impl(port, ptr, rust_vec_len, data_len),
        6 => {
            wire__crate__api__bridge__comic_classify_filters_impl(port, ptr, rust_vec_len, data_len)
        }
        7 => wire__crate__api__bridge__comic_classify_filters_old_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        8 => wire__crate__api__bridge__comic_classify_with_level_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        9 => wire__crate__api__bridge__comic_detail_impl(port, ptr, rust_vec_len, data_len),
        10 => wire__crate__api__bridge__comic_rank_list_impl(port, ptr, rust_vec_len, data_len),
        11 => wire__crate__api__bridge__comic_recommend_impl(port, ptr, rust_vec_len, data_len),
        12 => wire__crate__api__bridge__comic_search_impl(port, ptr, rust_vec_len, data_len),
        13 => wire__crate__api__bridge__comic_update_list_impl(port, ptr, rust_vec_len, data_len),
        14 => wire__crate__api__bridge__comic_view_page_impl(port, ptr, rust_vec_len, data_len),
        15 => wire__crate__api__bridge__comment_impl(port, ptr, rust_vec_len, data_len),
        16 => wire__crate__api__bridge__comment_v3_impl(port, ptr, rust_vec_len, data_len),
        17 => wire__crate__api__bridge__comment_v3_add_impl(port, ptr, rust_vec_len, data_len),
        18 => wire__crate__api__bridge__create_download_impl(port, ptr, rust_vec_len, data_len),
        19 => wire__crate__api__bridge__delete_download_impl(port, ptr, rust_vec_len, data_len),
        20 => wire__crate__api__bridge__desktop_root_impl(port, ptr, rust_vec_len, data_len),
        21 => wire__crate__api__bridge__download_comic_chapters_by_comic_id_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        22 => wire__crate__api__bridge__download_comic_page_by_chapter_id_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        24 => wire__crate__api__bridge__http_get_impl(port, ptr, rust_vec_len, data_len),
        25 => wire__crate__api__bridge__init_impl(port, ptr, rust_vec_len, data_len),
        26 => wire__crate__api__simple__init_app_impl(port, ptr, rust_vec_len, data_len),
        27 => wire__crate__api__bridge__load_cache_image_impl(port, ptr, rust_vec_len, data_len),
        28 => wire__crate__api__bridge__load_comic_id_impl(port, ptr, rust_vec_len, data_len),
        29 => {
            wire__crate__api__bridge__load_comic_view_logs_impl(port, ptr, rust_vec_len, data_len)
        }
        30 => {
            wire__crate__api__bridge__load_novel_view_logs_impl(port, ptr, rust_vec_len, data_len)
        }
        31 => wire__crate__api__bridge__load_property_impl(port, ptr, rust_vec_len, data_len),
        32 => wire__crate__api__bridge__news_categories_impl(port, ptr, rust_vec_len, data_len),
        33 => wire__crate__api__bridge__news_list_impl(port, ptr, rust_vec_len, data_len),
        34 => wire__crate__api__bridge__novel_categories_impl(port, ptr, rust_vec_len, data_len),
        35 => wire__crate__api__bridge__novel_chapters_impl(port, ptr, rust_vec_len, data_len),
        36 => wire__crate__api__bridge__novel_content_impl(port, ptr, rust_vec_len, data_len),
        37 => wire__crate__api__bridge__novel_detail_impl(port, ptr, rust_vec_len, data_len),
        38 => wire__crate__api__bridge__novel_list_impl(port, ptr, rust_vec_len, data_len),
        39 => wire__crate__api__bridge__novel_search_impl(port, ptr, rust_vec_len, data_len),
        40 => wire__crate__api__bridge__novel_view_page_impl(port, ptr, rust_vec_len, data_len),
        41 => wire__crate__api__bridge__pre_login_impl(port, ptr, rust_vec_len, data_len),
        42 => wire__crate__api__bridge__re_login_impl(port, ptr, rust_vec_len, data_len),
        43 => wire__crate__api__bridge__renew_all_downloads_impl(port, ptr, rust_vec_len, data_len),
        44 => wire__crate__api__bridge__save_property_impl(port, ptr, rust_vec_len, data_len),
        45 => wire__crate__api__bridge__subscribe_add_impl(port, ptr, rust_vec_len, data_len),
        46 => wire__crate__api__bridge__subscribe_cancel_impl(port, ptr, rust_vec_len, data_len),
        47 => wire__crate__api__bridge__subscribed_list_impl(port, ptr, rust_vec_len, data_len),
        48 => wire__crate__api__bridge__subscribed_obj_impl(port, ptr, rust_vec_len, data_len),
        49 => wire__crate__api__bridge__task_index_impl(port, ptr, rust_vec_len, data_len),
        50 => wire__crate__api__bridge__task_sign_impl(port, ptr, rust_vec_len, data_len),
        51 => {
            wire__crate__api__bridge__view_log_by_comic_id_impl(port, ptr, rust_vec_len, data_len)
        }
        52 => {
            wire__crate__api__bridge__view_log_by_novel_id_impl(port, ptr, rust_vec_len, data_len)
        }
        _ => unreachable!(),
    }
}

fn pde_ffi_dispatcher_sync_impl(
    func_id: i32,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        23 => wire__crate__api__simple__greet_impl(ptr, rust_vec_len, data_len),
        _ => unreachable!(),
    }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::anime_home::entities::ApiComment {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.obj_id.into_into_dart().into_dart(),
            self.content.into_into_dart().into_dart(),
            self.sender_ip.into_into_dart().into_dart(),
            self.sender_uid.into_into_dart().into_dart(),
            self.is_goods.into_into_dart().into_dart(),
            self.upload_images.into_into_dart().into_dart(),
            self.create_time.into_into_dart().into_dart(),
            self.like_amount.into_into_dart().into_dart(),
            self.sender_terminal.into_into_dart().into_dart(),
            self.origin_comment_id.into_into_dart().into_dart(),
            self.nickname.into_into_dart().into_dart(),
            self.user_level.into_into_dart().into_dart(),
            self.m_period.into_into_dart().into_dart(),
            self.m_cate.into_into_dart().into_dart(),
            self.is_fee_user.into_into_dart().into_dart(),
            self.avatar_url.into_into_dart().into_dart(),
            self.sex.into_into_dart().into_dart(),
            self.is_like.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::anime_home::entities::ApiComment
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::anime_home::entities::ApiComment>
    for crate::anime_home::entities::ApiComment
{
    fn into_into_dart(self) -> crate::anime_home::entities::ApiComment {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::anime_home::entities::ApiCommentResponse {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.comment_ids.into_into_dart().into_dart(),
            self.comments.into_into_dart().into_dart(),
            self.total.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::anime_home::entities::ApiCommentResponse
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::anime_home::entities::ApiCommentResponse>
    for crate::anime_home::entities::ApiCommentResponse
{
    fn into_into_dart(self) -> crate::anime_home::entities::ApiCommentResponse {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::anime_home::entities::Author {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.nickname.into_into_dart().into_dart(),
            self.description.into_into_dart().into_dart(),
            self.cover.into_into_dart().into_dart(),
            self.data.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::anime_home::entities::Author
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::anime_home::entities::Author>
    for crate::anime_home::entities::Author
{
    fn into_into_dart(self) -> crate::anime_home::entities::Author {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::anime_home::entities::ComicCategory {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.tag_id.into_into_dart().into_dart(),
            self.title.into_into_dart().into_dart(),
            self.cover.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::anime_home::entities::ComicCategory
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::anime_home::entities::ComicCategory>
    for crate::anime_home::entities::ComicCategory
{
    fn into_into_dart(self) -> crate::anime_home::entities::ComicCategory {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::anime_home::proto::ComicChapter {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.title.into_into_dart().into_dart(),
            self.data.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::anime_home::proto::ComicChapter
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::anime_home::proto::ComicChapter>
    for crate::anime_home::proto::ComicChapter
{
    fn into_into_dart(self) -> crate::anime_home::proto::ComicChapter {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::anime_home::proto::ComicChapterDetail {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.chapter_id.into_into_dart().into_dart(),
            self.comic_id.into_into_dart().into_dart(),
            self.title.into_into_dart().into_dart(),
            self.chapter_order.into_into_dart().into_dart(),
            self.direction.into_into_dart().into_dart(),
            self.page_url.into_into_dart().into_dart(),
            self.picnum.into_into_dart().into_dart(),
            self.page_url_hd.into_into_dart().into_dart(),
            self.comment_count.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::anime_home::proto::ComicChapterDetail
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::anime_home::proto::ComicChapterDetail>
    for crate::anime_home::proto::ComicChapterDetail
{
    fn into_into_dart(self) -> crate::anime_home::proto::ComicChapterDetail {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::anime_home::proto::ComicChapterInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.chapter_id.into_into_dart().into_dart(),
            self.chapter_title.into_into_dart().into_dart(),
            self.update_time.into_into_dart().into_dart(),
            self.file_size.into_into_dart().into_dart(),
            self.chapter_order.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::anime_home::proto::ComicChapterInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::anime_home::proto::ComicChapterInfo>
    for crate::anime_home::proto::ComicChapterInfo
{
    fn into_into_dart(self) -> crate::anime_home::proto::ComicChapterInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::anime_home::proto::ComicDetail {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.title.into_into_dart().into_dart(),
            self.direction.into_into_dart().into_dart(),
            self.is_long.into_into_dart().into_dart(),
            self.is_anime_home.into_into_dart().into_dart(),
            self.cover.into_into_dart().into_dart(),
            self.description.into_into_dart().into_dart(),
            self.last_update_time.into_into_dart().into_dart(),
            self.last_update_chapter_name.into_into_dart().into_dart(),
            self.copyright.into_into_dart().into_dart(),
            self.first_letter.into_into_dart().into_dart(),
            self.comic_py.into_into_dart().into_dart(),
            self.hidden.into_into_dart().into_dart(),
            self.hot_num.into_into_dart().into_dart(),
            self.hit_num.into_into_dart().into_dart(),
            self.uid.into_into_dart().into_dart(),
            self.is_lock.into_into_dart().into_dart(),
            self.last_update_chapter_id.into_into_dart().into_dart(),
            self.types.into_into_dart().into_dart(),
            self.status.into_into_dart().into_dart(),
            self.authors.into_into_dart().into_dart(),
            self.subscribe_num.into_into_dart().into_dart(),
            self.chapters.into_into_dart().into_dart(),
            self.is_need_login.into_into_dart().into_dart(),
            self.is_hide_chapter.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::anime_home::proto::ComicDetail
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::anime_home::proto::ComicDetail>
    for crate::anime_home::proto::ComicDetail
{
    fn into_into_dart(self) -> crate::anime_home::proto::ComicDetail {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::anime_home::entities::ComicFilter {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.title.into_into_dart().into_dart(),
            self.items.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::anime_home::entities::ComicFilter
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::anime_home::entities::ComicFilter>
    for crate::anime_home::entities::ComicFilter
{
    fn into_into_dart(self) -> crate::anime_home::entities::ComicFilter {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::anime_home::entities::ComicFilterItem {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.tag_id.into_into_dart().into_dart(),
            self.tag_name.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::anime_home::entities::ComicFilterItem
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::anime_home::entities::ComicFilterItem>
    for crate::anime_home::entities::ComicFilterItem
{
    fn into_into_dart(self) -> crate::anime_home::entities::ComicFilterItem {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::anime_home::entities::ComicInAuthor {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.name.into_into_dart().into_dart(),
            self.cover.into_into_dart().into_dart(),
            self.status.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::anime_home::entities::ComicInAuthor
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::anime_home::entities::ComicInAuthor>
    for crate::anime_home::entities::ComicInAuthor
{
    fn into_into_dart(self) -> crate::anime_home::entities::ComicInAuthor {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::anime_home::entities::ComicInFilter {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.title.into_into_dart().into_dart(),
            self.authors.into_into_dart().into_dart(),
            self.status.into_into_dart().into_dart(),
            self.cover.into_into_dart().into_dart(),
            self.types.into_into_dart().into_dart(),
            self.last_update_time.into_into_dart().into_dart(),
            self.num.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::anime_home::entities::ComicInFilter
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::anime_home::entities::ComicInFilter>
    for crate::anime_home::entities::ComicInFilter
{
    fn into_into_dart(self) -> crate::anime_home::entities::ComicInFilter {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::anime_home::entities::ComicInSearch {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.biz.into_into_dart().into_dart(),
            self.addtime.into_into_dart().into_dart(),
            self.authors.into_into_dart().into_dart(),
            self.copyright.into_into_dart().into_dart(),
            self.cover.into_into_dart().into_dart(),
            self.hidden.into_into_dart().into_dart(),
            self.hot_hits.into_into_dart().into_dart(),
            self.last_name.into_into_dart().into_dart(),
            self.status.into_into_dart().into_dart(),
            self.title.into_into_dart().into_dart(),
            self.types.into_into_dart().into_dart(),
            self.id.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::anime_home::entities::ComicInSearch
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::anime_home::entities::ComicInSearch>
    for crate::anime_home::entities::ComicInSearch
{
    fn into_into_dart(self) -> crate::anime_home::entities::ComicInSearch {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::anime_home::proto::ComicRankListItem {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.title.into_into_dart().into_dart(),
            self.authors.into_into_dart().into_dart(),
            self.status.into_into_dart().into_dart(),
            self.cover.into_into_dart().into_dart(),
            self.types.into_into_dart().into_dart(),
            self.last_update_time.into_into_dart().into_dart(),
            self.last_update_chapter_name.into_into_dart().into_dart(),
            self.comic_py.into_into_dart().into_dart(),
            self.num.into_into_dart().into_dart(),
            self.tag_id.into_into_dart().into_dart(),
            self.chapter_name.into_into_dart().into_dart(),
            self.chapter_id.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::anime_home::proto::ComicRankListItem
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::anime_home::proto::ComicRankListItem>
    for crate::anime_home::proto::ComicRankListItem
{
    fn into_into_dart(self) -> crate::anime_home::proto::ComicRankListItem {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::anime_home::proto::ComicUpdateListItem {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.title.into_into_dart().into_dart(),
            self.is_long.into_into_dart().into_dart(),
            self.authors.into_into_dart().into_dart(),
            self.types.into_into_dart().into_dart(),
            self.cover.into_into_dart().into_dart(),
            self.status.into_into_dart().into_dart(),
            self.last_update_chapter_name.into_into_dart().into_dart(),
            self.last_update_chapter_id.into_into_dart().into_dart(),
            self.last_update_time.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::anime_home::proto::ComicUpdateListItem
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::anime_home::proto::ComicUpdateListItem>
    for crate::anime_home::proto::ComicUpdateListItem
{
    fn into_into_dart(self) -> crate::anime_home::proto::ComicUpdateListItem {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::bridge::ComicViewLog {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.comic_id.into_into_dart().into_dart(),
            self.comic_title.into_into_dart().into_dart(),
            self.comic_authors.into_into_dart().into_dart(),
            self.comic_status.into_into_dart().into_dart(),
            self.comic_cover.into_into_dart().into_dart(),
            self.comic_types.into_into_dart().into_dart(),
            self.comic_last_update_time.into_into_dart().into_dart(),
            self.comic_last_update_chapter_name
                .into_into_dart()
                .into_dart(),
            self.chapter_id.into_into_dart().into_dart(),
            self.chapter_title.into_into_dart().into_dart(),
            self.chapter_order.into_into_dart().into_dart(),
            self.page_rank.into_into_dart().into_dart(),
            self.view_time.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::bridge::ComicViewLog
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::bridge::ComicViewLog>
    for crate::api::bridge::ComicViewLog
{
    fn into_into_dart(self) -> crate::api::bridge::ComicViewLog {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::anime_home::entities::Comment {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.is_passed.into_into_dart().into_dart(),
            self.top_status.into_into_dart().into_dart(),
            self.is_goods.into_into_dart().into_dart(),
            self.upload_images.into_into_dart().into_dart(),
            self.obj_id.into_into_dart().into_dart(),
            self.content.into_into_dart().into_dart(),
            self.sender_uid.into_into_dart().into_dart(),
            self.like_amount.into_into_dart().into_dart(),
            self.create_time.into_into_dart().into_dart(),
            self.to_uid.into_into_dart().into_dart(),
            self.to_comment_id.into_into_dart().into_dart(),
            self.origin_comment_id.into_into_dart().into_dart(),
            self.reply_amount.into_into_dart().into_dart(),
            self.hot_comment_amount.into_into_dart().into_dart(),
            self.cover.into_into_dart().into_dart(),
            self.nickname.into_into_dart().into_dart(),
            self.avatar_url.into_into_dart().into_dart(),
            self.sex.into_into_dart().into_dart(),
            self.master_comment_num.into_into_dart().into_dart(),
            self.master_comment.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::anime_home::entities::Comment
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::anime_home::entities::Comment>
    for crate::anime_home::entities::Comment
{
    fn into_into_dart(self) -> crate::anime_home::entities::Comment {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::anime_home::entities::DayList {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.title.into_into_dart().into_dart(),
            self.icon.into_into_dart().into_dart(),
            self.icon_checked.into_into_dart().into_dart(),
            self.type_id.into_into_dart().into_dart(),
            self.times.into_into_dart().into_dart(),
            self.nums.into_into_dart().into_dart(),
            self.credits_nums.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::anime_home::entities::DayList
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::anime_home::entities::DayList>
    for crate::anime_home::entities::DayList
{
    fn into_into_dart(self) -> crate::anime_home::entities::DayList {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::anime_home::entities::DaySignTask {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.current_day.into_into_dart().into_dart(),
            self.status.into_into_dart().into_dart(),
            self.double_status.into_into_dart().into_dart(),
            self.day_list.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::anime_home::entities::DaySignTask
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::anime_home::entities::DaySignTask>
    for crate::anime_home::entities::DaySignTask
{
    fn into_into_dart(self) -> crate::anime_home::entities::DaySignTask {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::bridge::DownloadComic {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.title.into_into_dart().into_dart(),
            self.authors.into_into_dart().into_dart(),
            self.types.into_into_dart().into_dart(),
            self.status.into_into_dart().into_dart(),
            self.direction.into_into_dart().into_dart(),
            self.is_long.into_into_dart().into_dart(),
            self.is_anime_home.into_into_dart().into_dart(),
            self.cover.into_into_dart().into_dart(),
            self.description.into_into_dart().into_dart(),
            self.copyright.into_into_dart().into_dart(),
            self.first_letter.into_into_dart().into_dart(),
            self.comic_py.into_into_dart().into_dart(),
            self.cover_download_status.into_into_dart().into_dart(),
            self.cover_format.into_into_dart().into_dart(),
            self.cover_width.into_into_dart().into_dart(),
            self.cover_height.into_into_dart().into_dart(),
            self.download_status.into_into_dart().into_dart(),
            self.image_count.into_into_dart().into_dart(),
            self.image_count_download.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::bridge::DownloadComic
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::bridge::DownloadComic>
    for crate::api::bridge::DownloadComic
{
    fn into_into_dart(self) -> crate::api::bridge::DownloadComic {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::anime_home::proto::Item {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.title.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::anime_home::proto::Item
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::anime_home::proto::Item>
    for crate::anime_home::proto::Item
{
    fn into_into_dart(self) -> crate::anime_home::proto::Item {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::bridge::LocalImage {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.abs_path.into_into_dart().into_dart(),
            self.local_path.into_into_dart().into_dart(),
            self.image_format.into_into_dart().into_dart(),
            self.image_width.into_into_dart().into_dart(),
            self.image_height.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::bridge::LocalImage
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::bridge::LocalImage>
    for crate::api::bridge::LocalImage
{
    fn into_into_dart(self) -> crate::api::bridge::LocalImage {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::anime_home::entities::LoginData {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.uid.into_into_dart().into_dart(),
            self.nickname.into_into_dart().into_dart(),
            self.dmzj_token.into_into_dart().into_dart(),
            self.photo.into_into_dart().into_dart(),
            self.bind_phone.into_into_dart().into_dart(),
            self.email.into_into_dart().into_dart(),
            self.passwd.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::anime_home::entities::LoginData
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::anime_home::entities::LoginData>
    for crate::anime_home::entities::LoginData
{
    fn into_into_dart(self) -> crate::anime_home::entities::LoginData {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::bridge::LoginInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.status.into_into_dart().into_dart(),
            self.message.into_into_dart().into_dart(),
            self.data.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::bridge::LoginInfo {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::bridge::LoginInfo>
    for crate::api::bridge::LoginInfo
{
    fn into_into_dart(self) -> crate::api::bridge::LoginInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::anime_home::entities::MasterComment {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.is_passed.into_into_dart().into_dart(),
            self.top_status.into_into_dart().into_dart(),
            self.is_goods.into_into_dart().into_dart(),
            self.upload_images.into_into_dart().into_dart(),
            self.obj_id.into_into_dart().into_dart(),
            self.content.into_into_dart().into_dart(),
            self.sender_uid.into_into_dart().into_dart(),
            self.like_amount.into_into_dart().into_dart(),
            self.create_time.into_into_dart().into_dart(),
            self.to_uid.into_into_dart().into_dart(),
            self.to_comment_id.into_into_dart().into_dart(),
            self.origin_comment_id.into_into_dart().into_dart(),
            self.reply_amount.into_into_dart().into_dart(),
            self.cover.into_into_dart().into_dart(),
            self.nickname.into_into_dart().into_dart(),
            self.hot_comment_amount.into_into_dart().into_dart(),
            self.sex.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::anime_home::entities::MasterComment
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::anime_home::entities::MasterComment>
    for crate::anime_home::entities::MasterComment
{
    fn into_into_dart(self) -> crate::anime_home::entities::MasterComment {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::anime_home::entities::NewsCategory {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.tag_id.into_into_dart().into_dart(),
            self.tag_name.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::anime_home::entities::NewsCategory
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::anime_home::entities::NewsCategory>
    for crate::anime_home::entities::NewsCategory
{
    fn into_into_dart(self) -> crate::anime_home::entities::NewsCategory {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::anime_home::proto::NewsListItem {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.title.into_into_dart().into_dart(),
            self.from_name.into_into_dart().into_dart(),
            self.from_url.into_into_dart().into_dart(),
            self.create_time.into_into_dart().into_dart(),
            self.is_foreign.into_into_dart().into_dart(),
            self.foreign_url.into_into_dart().into_dart(),
            self.intro.into_into_dart().into_dart(),
            self.author_id.into_into_dart().into_dart(),
            self.status.into_into_dart().into_dart(),
            self.row_pic_url.into_into_dart().into_dart(),
            self.col_pic_url.into_into_dart().into_dart(),
            self.q_chat_show.into_into_dart().into_dart(),
            self.page_url.into_into_dart().into_dart(),
            self.comment_amount.into_into_dart().into_dart(),
            self.author_uid.into_into_dart().into_dart(),
            self.cover.into_into_dart().into_dart(),
            self.nickname.into_into_dart().into_dart(),
            self.mood_amount.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::anime_home::proto::NewsListItem
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::anime_home::proto::NewsListItem>
    for crate::anime_home::proto::NewsListItem
{
    fn into_into_dart(self) -> crate::anime_home::proto::NewsListItem {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::anime_home::entities::NovelCategory {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.tag_id.into_into_dart().into_dart(),
            self.title.into_into_dart().into_dart(),
            self.cover.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::anime_home::entities::NovelCategory
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::anime_home::entities::NovelCategory>
    for crate::anime_home::entities::NovelCategory
{
    fn into_into_dart(self) -> crate::anime_home::entities::NovelCategory {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::anime_home::proto::NovelChapter {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.chapter_id.into_into_dart().into_dart(),
            self.chapter_name.into_into_dart().into_dart(),
            self.chapter_order.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::anime_home::proto::NovelChapter
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::anime_home::proto::NovelChapter>
    for crate::anime_home::proto::NovelChapter
{
    fn into_into_dart(self) -> crate::anime_home::proto::NovelChapter {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::anime_home::proto::NovelDetail {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.name.into_into_dart().into_dart(),
            self.zone.into_into_dart().into_dart(),
            self.status.into_into_dart().into_dart(),
            self.last_update_volume_name.into_into_dart().into_dart(),
            self.last_update_chapter_name.into_into_dart().into_dart(),
            self.last_update_volume_id.into_into_dart().into_dart(),
            self.last_update_chapter_id.into_into_dart().into_dart(),
            self.last_update_time.into_into_dart().into_dart(),
            self.cover.into_into_dart().into_dart(),
            self.hot_hits.into_into_dart().into_dart(),
            self.introduction.into_into_dart().into_dart(),
            self.types.into_into_dart().into_dart(),
            self.authors.into_into_dart().into_dart(),
            self.first_letter.into_into_dart().into_dart(),
            self.subscribe_num.into_into_dart().into_dart(),
            self.redis_update_time.into_into_dart().into_dart(),
            self.volumes.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::anime_home::proto::NovelDetail
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::anime_home::proto::NovelDetail>
    for crate::anime_home::proto::NovelDetail
{
    fn into_into_dart(self) -> crate::anime_home::proto::NovelDetail {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::anime_home::entities::NovelInFilter {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.cover.into_into_dart().into_dart(),
            self.name.into_into_dart().into_dart(),
            self.authors.into_into_dart().into_dart(),
            self.id.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::anime_home::entities::NovelInFilter
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::anime_home::entities::NovelInFilter>
    for crate::anime_home::entities::NovelInFilter
{
    fn into_into_dart(self) -> crate::anime_home::entities::NovelInFilter {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::anime_home::entities::NovelInSearch {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.biz.into_into_dart().into_dart(),
            self.addtime.into_into_dart().into_dart(),
            self.authors.into_into_dart().into_dart(),
            self.copyright.into_into_dart().into_dart(),
            self.cover.into_into_dart().into_dart(),
            self.hidden.into_into_dart().into_dart(),
            self.hot_hits.into_into_dart().into_dart(),
            self.last_name.into_into_dart().into_dart(),
            self.status.into_into_dart().into_dart(),
            self.title.into_into_dart().into_dart(),
            self.types.into_into_dart().into_dart(),
            self.id.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::anime_home::entities::NovelInSearch
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::anime_home::entities::NovelInSearch>
    for crate::anime_home::entities::NovelInSearch
{
    fn into_into_dart(self) -> crate::anime_home::entities::NovelInSearch {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::bridge::NovelViewLog {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.novel_id.into_into_dart().into_dart(),
            self.novel_title.into_into_dart().into_dart(),
            self.novel_zone.into_into_dart().into_dart(),
            self.novel_status.into_into_dart().into_dart(),
            self.novel_last_update_volume_name
                .into_into_dart()
                .into_dart(),
            self.novel_last_update_chapter_name
                .into_into_dart()
                .into_dart(),
            self.novel_last_update_volume_id
                .into_into_dart()
                .into_dart(),
            self.novel_last_update_chapter_id
                .into_into_dart()
                .into_dart(),
            self.novel_last_update_time.into_into_dart().into_dart(),
            self.novel_cover.into_into_dart().into_dart(),
            self.novel_hot_hits.into_into_dart().into_dart(),
            self.novel_introduction.into_into_dart().into_dart(),
            self.novel_types.into_into_dart().into_dart(),
            self.novel_authors.into_into_dart().into_dart(),
            self.novel_first_letter.into_into_dart().into_dart(),
            self.novel_subscribe_num.into_into_dart().into_dart(),
            self.novel_redis_update_time.into_into_dart().into_dart(),
            self.volume_id.into_into_dart().into_dart(),
            self.volume_title.into_into_dart().into_dart(),
            self.volume_order.into_into_dart().into_dart(),
            self.chapter_id.into_into_dart().into_dart(),
            self.chapter_title.into_into_dart().into_dart(),
            self.chapter_order.into_into_dart().into_dart(),
            self.progress.into_into_dart().into_dart(),
            self.view_time.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::bridge::NovelViewLog
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::bridge::NovelViewLog>
    for crate::api::bridge::NovelViewLog
{
    fn into_into_dart(self) -> crate::api::bridge::NovelViewLog {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::anime_home::proto::NovelVolume {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.title.into_into_dart().into_dart(),
            self.rank.into_into_dart().into_dart(),
            self.chapters.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::anime_home::proto::NovelVolume
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::anime_home::proto::NovelVolume>
    for crate::anime_home::proto::NovelVolume
{
    fn into_into_dart(self) -> crate::anime_home::proto::NovelVolume {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::anime_home::proto::NovelVolumeInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.novel_id.into_into_dart().into_dart(),
            self.title.into_into_dart().into_dart(),
            self.rank.into_into_dart().into_dart(),
            self.add_time.into_into_dart().into_dart(),
            self.chapters_count.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::anime_home::proto::NovelVolumeInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::anime_home::proto::NovelVolumeInfo>
    for crate::anime_home::proto::NovelVolumeInfo
{
    fn into_into_dart(self) -> crate::anime_home::proto::NovelVolumeInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::anime_home::entities::Subscribed {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.name.into_into_dart().into_dart(),
            self.sub_update.into_into_dart().into_dart(),
            self.sub_img.into_into_dart().into_dart(),
            self.sub_uptime.into_into_dart().into_dart(),
            self.sub_first_letter.into_into_dart().into_dart(),
            self.sub_readed.into_into_dart().into_dart(),
            self.id.into_into_dart().into_dart(),
            self.status.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::anime_home::entities::Subscribed
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::anime_home::entities::Subscribed>
    for crate::anime_home::entities::Subscribed
{
    fn into_into_dart(self) -> crate::anime_home::entities::Subscribed {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::anime_home::entities::SummationsTask {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.sign_count.into_into_dart().into_dart(),
            self.max_sign_count.into_into_dart().into_dart(),
            self.task_list.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::anime_home::entities::SummationsTask
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::anime_home::entities::SummationsTask>
    for crate::anime_home::entities::SummationsTask
{
    fn into_into_dart(self) -> crate::anime_home::entities::SummationsTask {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::anime_home::entities::Task {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.title.into_into_dart().into_dart(),
            self.con.into_into_dart().into_dart(),
            self.icon.into_into_dart().into_dart(),
            self.times.into_into_dart().into_dart(),
            self.nums.into_into_dart().into_dart(),
            self.source.into_into_dart().into_dart(),
            self.type_id.into_into_dart().into_dart(),
            self.url.into_into_dart().into_dart(),
            self.btn.into_into_dart().into_dart(),
            self.status.into_into_dart().into_dart(),
            self.progress.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::anime_home::entities::Task
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::anime_home::entities::Task>
    for crate::anime_home::entities::Task
{
    fn into_into_dart(self) -> crate::anime_home::entities::Task {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::anime_home::entities::TaskIndex {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.new_person_task.into_into_dart().into_dart(),
            self.day_task.into_into_dart().into_dart(),
            self.week_task.into_into_dart().into_dart(),
            self.summations_task.into_into_dart().into_dart(),
            self.day_sign_task.into_into_dart().into_dart(),
            self.credits_nums.into_into_dart().into_dart(),
            self.silver_nums.into_into_dart().into_dart(),
            self.stars_nums.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::anime_home::entities::TaskIndex
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::anime_home::entities::TaskIndex>
    for crate::anime_home::entities::TaskIndex
{
    fn into_into_dart(self) -> crate::anime_home::entities::TaskIndex {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::anime_home::entities::TaskList {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.title.into_into_dart().into_dart(),
            self.con.into_into_dart().into_dart(),
            self.icon.into_into_dart().into_dart(),
            self.times.into_into_dart().into_dart(),
            self.nums.into_into_dart().into_dart(),
            self.source.into_into_dart().into_dart(),
            self.type_id.into_into_dart().into_dart(),
            self.url.into_into_dart().into_dart(),
            self.btn.into_into_dart().into_dart(),
            self.status.into_into_dart().into_dart(),
            self.progress.into_into_dart().into_dart(),
            self.icon_checked.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::anime_home::entities::TaskList
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::anime_home::entities::TaskList>
    for crate::anime_home::entities::TaskList
{
    fn into_into_dart(self) -> crate::anime_home::entities::TaskList {
        self
    }
}

impl SseEncode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(format!("{:?}", self), serializer);
    }
}

impl SseEncode for std::collections::HashMap<String, crate::anime_home::entities::ApiComment> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(String, crate::anime_home::entities::ApiComment)>>::sse_encode(
            self.into_iter().collect(),
            serializer,
        );
    }
}

impl SseEncode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
    }
}

impl SseEncode for crate::anime_home::entities::ApiComment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <String>::sse_encode(self.obj_id, serializer);
        <String>::sse_encode(self.content, serializer);
        <String>::sse_encode(self.sender_ip, serializer);
        <String>::sse_encode(self.sender_uid, serializer);
        <String>::sse_encode(self.is_goods, serializer);
        <String>::sse_encode(self.upload_images, serializer);
        <String>::sse_encode(self.create_time, serializer);
        <String>::sse_encode(self.like_amount, serializer);
        <String>::sse_encode(self.sender_terminal, serializer);
        <String>::sse_encode(self.origin_comment_id, serializer);
        <String>::sse_encode(self.nickname, serializer);
        <String>::sse_encode(self.user_level, serializer);
        <String>::sse_encode(self.m_period, serializer);
        <String>::sse_encode(self.m_cate, serializer);
        <bool>::sse_encode(self.is_fee_user, serializer);
        <String>::sse_encode(self.avatar_url, serializer);
        <String>::sse_encode(self.sex, serializer);
        <bool>::sse_encode(self.is_like, serializer);
    }
}

impl SseEncode for crate::anime_home::entities::ApiCommentResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<String>>::sse_encode(self.comment_ids, serializer);
        <std::collections::HashMap<String, crate::anime_home::entities::ApiComment>>::sse_encode(
            self.comments,
            serializer,
        );
        <i64>::sse_encode(self.total, serializer);
    }
}

impl SseEncode for crate::anime_home::entities::Author {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.nickname, serializer);
        <String>::sse_encode(self.description, serializer);
        <String>::sse_encode(self.cover, serializer);
        <Vec<crate::anime_home::entities::ComicInAuthor>>::sse_encode(self.data, serializer);
    }
}

impl SseEncode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode for crate::anime_home::entities::ComicCategory {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.tag_id, serializer);
        <String>::sse_encode(self.title, serializer);
        <String>::sse_encode(self.cover, serializer);
    }
}

impl SseEncode for crate::anime_home::proto::ComicChapter {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.title, serializer);
        <Vec<crate::anime_home::proto::ComicChapterInfo>>::sse_encode(self.data, serializer);
    }
}

impl SseEncode for crate::anime_home::proto::ComicChapterDetail {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i64>::sse_encode(self.chapter_id, serializer);
        <i64>::sse_encode(self.comic_id, serializer);
        <String>::sse_encode(self.title, serializer);
        <i32>::sse_encode(self.chapter_order, serializer);
        <i32>::sse_encode(self.direction, serializer);
        <Vec<String>>::sse_encode(self.page_url, serializer);
        <i32>::sse_encode(self.picnum, serializer);
        <Vec<String>>::sse_encode(self.page_url_hd, serializer);
        <i32>::sse_encode(self.comment_count, serializer);
    }
}

impl SseEncode for crate::anime_home::proto::ComicChapterInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.chapter_id, serializer);
        <String>::sse_encode(self.chapter_title, serializer);
        <i64>::sse_encode(self.update_time, serializer);
        <i32>::sse_encode(self.file_size, serializer);
        <i32>::sse_encode(self.chapter_order, serializer);
    }
}

impl SseEncode for crate::anime_home::proto::ComicDetail {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.id, serializer);
        <String>::sse_encode(self.title, serializer);
        <i32>::sse_encode(self.direction, serializer);
        <i32>::sse_encode(self.is_long, serializer);
        <i32>::sse_encode(self.is_anime_home, serializer);
        <String>::sse_encode(self.cover, serializer);
        <String>::sse_encode(self.description, serializer);
        <i64>::sse_encode(self.last_update_time, serializer);
        <String>::sse_encode(self.last_update_chapter_name, serializer);
        <i32>::sse_encode(self.copyright, serializer);
        <String>::sse_encode(self.first_letter, serializer);
        <String>::sse_encode(self.comic_py, serializer);
        <i32>::sse_encode(self.hidden, serializer);
        <i32>::sse_encode(self.hot_num, serializer);
        <i32>::sse_encode(self.hit_num, serializer);
        <i32>::sse_encode(self.uid, serializer);
        <i32>::sse_encode(self.is_lock, serializer);
        <i32>::sse_encode(self.last_update_chapter_id, serializer);
        <Vec<crate::anime_home::proto::Item>>::sse_encode(self.types, serializer);
        <Vec<crate::anime_home::proto::Item>>::sse_encode(self.status, serializer);
        <Vec<crate::anime_home::proto::Item>>::sse_encode(self.authors, serializer);
        <i32>::sse_encode(self.subscribe_num, serializer);
        <Vec<crate::anime_home::proto::ComicChapter>>::sse_encode(self.chapters, serializer);
        <i32>::sse_encode(self.is_need_login, serializer);
        <i32>::sse_encode(self.is_hide_chapter, serializer);
    }
}

impl SseEncode for crate::anime_home::entities::ComicFilter {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.title, serializer);
        <Vec<crate::anime_home::entities::ComicFilterItem>>::sse_encode(self.items, serializer);
    }
}

impl SseEncode for crate::anime_home::entities::ComicFilterItem {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i64>::sse_encode(self.tag_id, serializer);
        <String>::sse_encode(self.tag_name, serializer);
    }
}

impl SseEncode for crate::anime_home::entities::ComicInAuthor {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i64>::sse_encode(self.id, serializer);
        <String>::sse_encode(self.name, serializer);
        <String>::sse_encode(self.cover, serializer);
        <String>::sse_encode(self.status, serializer);
    }
}

impl SseEncode for crate::anime_home::entities::ComicInFilter {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i64>::sse_encode(self.id, serializer);
        <String>::sse_encode(self.title, serializer);
        <String>::sse_encode(self.authors, serializer);
        <String>::sse_encode(self.status, serializer);
        <String>::sse_encode(self.cover, serializer);
        <String>::sse_encode(self.types, serializer);
        <i64>::sse_encode(self.last_update_time, serializer);
        <i64>::sse_encode(self.num, serializer);
    }
}

impl SseEncode for crate::anime_home::entities::ComicInSearch {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.biz, serializer);
        <i64>::sse_encode(self.addtime, serializer);
        <String>::sse_encode(self.authors, serializer);
        <i64>::sse_encode(self.copyright, serializer);
        <String>::sse_encode(self.cover, serializer);
        <i64>::sse_encode(self.hidden, serializer);
        <i64>::sse_encode(self.hot_hits, serializer);
        <String>::sse_encode(self.last_name, serializer);
        <i64>::sse_encode(self.status, serializer);
        <String>::sse_encode(self.title, serializer);
        <String>::sse_encode(self.types, serializer);
        <i64>::sse_encode(self.id, serializer);
    }
}

impl SseEncode for crate::anime_home::proto::ComicRankListItem {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.id, serializer);
        <String>::sse_encode(self.title, serializer);
        <String>::sse_encode(self.authors, serializer);
        <String>::sse_encode(self.status, serializer);
        <String>::sse_encode(self.cover, serializer);
        <String>::sse_encode(self.types, serializer);
        <i64>::sse_encode(self.last_update_time, serializer);
        <String>::sse_encode(self.last_update_chapter_name, serializer);
        <String>::sse_encode(self.comic_py, serializer);
        <i32>::sse_encode(self.num, serializer);
        <i32>::sse_encode(self.tag_id, serializer);
        <String>::sse_encode(self.chapter_name, serializer);
        <i32>::sse_encode(self.chapter_id, serializer);
    }
}

impl SseEncode for crate::anime_home::proto::ComicUpdateListItem {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.id, serializer);
        <String>::sse_encode(self.title, serializer);
        <bool>::sse_encode(self.is_long, serializer);
        <String>::sse_encode(self.authors, serializer);
        <String>::sse_encode(self.types, serializer);
        <String>::sse_encode(self.cover, serializer);
        <String>::sse_encode(self.status, serializer);
        <String>::sse_encode(self.last_update_chapter_name, serializer);
        <i32>::sse_encode(self.last_update_chapter_id, serializer);
        <i64>::sse_encode(self.last_update_time, serializer);
    }
}

impl SseEncode for crate::api::bridge::ComicViewLog {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.comic_id, serializer);
        <String>::sse_encode(self.comic_title, serializer);
        <String>::sse_encode(self.comic_authors, serializer);
        <String>::sse_encode(self.comic_status, serializer);
        <String>::sse_encode(self.comic_cover, serializer);
        <String>::sse_encode(self.comic_types, serializer);
        <i64>::sse_encode(self.comic_last_update_time, serializer);
        <String>::sse_encode(self.comic_last_update_chapter_name, serializer);
        <i32>::sse_encode(self.chapter_id, serializer);
        <String>::sse_encode(self.chapter_title, serializer);
        <i32>::sse_encode(self.chapter_order, serializer);
        <i32>::sse_encode(self.page_rank, serializer);
        <i64>::sse_encode(self.view_time, serializer);
    }
}

impl SseEncode for crate::anime_home::entities::Comment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i64>::sse_encode(self.id, serializer);
        <i64>::sse_encode(self.is_passed, serializer);
        <i64>::sse_encode(self.top_status, serializer);
        <i64>::sse_encode(self.is_goods, serializer);
        <String>::sse_encode(self.upload_images, serializer);
        <i64>::sse_encode(self.obj_id, serializer);
        <String>::sse_encode(self.content, serializer);
        <i64>::sse_encode(self.sender_uid, serializer);
        <i64>::sse_encode(self.like_amount, serializer);
        <i64>::sse_encode(self.create_time, serializer);
        <i64>::sse_encode(self.to_uid, serializer);
        <i64>::sse_encode(self.to_comment_id, serializer);
        <i64>::sse_encode(self.origin_comment_id, serializer);
        <i64>::sse_encode(self.reply_amount, serializer);
        <i64>::sse_encode(self.hot_comment_amount, serializer);
        <String>::sse_encode(self.cover, serializer);
        <String>::sse_encode(self.nickname, serializer);
        <String>::sse_encode(self.avatar_url, serializer);
        <i64>::sse_encode(self.sex, serializer);
        <i64>::sse_encode(self.master_comment_num, serializer);
        <Vec<crate::anime_home::entities::MasterComment>>::sse_encode(
            self.master_comment,
            serializer,
        );
    }
}

impl SseEncode for crate::anime_home::entities::DayList {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i64>::sse_encode(self.id, serializer);
        <String>::sse_encode(self.title, serializer);
        <String>::sse_encode(self.icon, serializer);
        <String>::sse_encode(self.icon_checked, serializer);
        <i64>::sse_encode(self.type_id, serializer);
        <i64>::sse_encode(self.times, serializer);
        <i64>::sse_encode(self.nums, serializer);
        <i64>::sse_encode(self.credits_nums, serializer);
    }
}

impl SseEncode for crate::anime_home::entities::DaySignTask {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i64>::sse_encode(self.current_day, serializer);
        <i64>::sse_encode(self.status, serializer);
        <i64>::sse_encode(self.double_status, serializer);
        <Vec<crate::anime_home::entities::DayList>>::sse_encode(self.day_list, serializer);
    }
}

impl SseEncode for crate::api::bridge::DownloadComic {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.id, serializer);
        <String>::sse_encode(self.title, serializer);
        <String>::sse_encode(self.authors, serializer);
        <String>::sse_encode(self.types, serializer);
        <String>::sse_encode(self.status, serializer);
        <i32>::sse_encode(self.direction, serializer);
        <i32>::sse_encode(self.is_long, serializer);
        <i32>::sse_encode(self.is_anime_home, serializer);
        <String>::sse_encode(self.cover, serializer);
        <String>::sse_encode(self.description, serializer);
        <i32>::sse_encode(self.copyright, serializer);
        <String>::sse_encode(self.first_letter, serializer);
        <String>::sse_encode(self.comic_py, serializer);
        <i32>::sse_encode(self.cover_download_status, serializer);
        <String>::sse_encode(self.cover_format, serializer);
        <u32>::sse_encode(self.cover_width, serializer);
        <u32>::sse_encode(self.cover_height, serializer);
        <i32>::sse_encode(self.download_status, serializer);
        <i32>::sse_encode(self.image_count, serializer);
        <i32>::sse_encode(self.image_count_download, serializer);
    }
}

impl SseEncode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for i64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::anime_home::proto::Item {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.id, serializer);
        <String>::sse_encode(self.title, serializer);
    }
}

impl SseEncode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <String>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::anime_home::entities::ComicCategory> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::anime_home::entities::ComicCategory>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::anime_home::proto::ComicChapter> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::anime_home::proto::ComicChapter>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::anime_home::proto::ComicChapterInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::anime_home::proto::ComicChapterInfo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::anime_home::entities::ComicFilter> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::anime_home::entities::ComicFilter>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::anime_home::entities::ComicFilterItem> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::anime_home::entities::ComicFilterItem>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::anime_home::entities::ComicInAuthor> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::anime_home::entities::ComicInAuthor>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::anime_home::entities::ComicInFilter> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::anime_home::entities::ComicInFilter>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::anime_home::entities::ComicInSearch> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::anime_home::entities::ComicInSearch>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::anime_home::proto::ComicRankListItem> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::anime_home::proto::ComicRankListItem>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::anime_home::proto::ComicUpdateListItem> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::anime_home::proto::ComicUpdateListItem>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::bridge::ComicViewLog> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::bridge::ComicViewLog>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::anime_home::entities::Comment> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::anime_home::entities::Comment>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::anime_home::entities::DayList> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::anime_home::entities::DayList>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::bridge::DownloadComic> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::bridge::DownloadComic>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::anime_home::proto::Item> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::anime_home::proto::Item>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::anime_home::entities::MasterComment> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::anime_home::entities::MasterComment>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::anime_home::entities::NewsCategory> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::anime_home::entities::NewsCategory>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::anime_home::proto::NewsListItem> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::anime_home::proto::NewsListItem>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::anime_home::entities::NovelCategory> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::anime_home::entities::NovelCategory>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::anime_home::proto::NovelChapter> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::anime_home::proto::NovelChapter>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::anime_home::entities::NovelInFilter> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::anime_home::entities::NovelInFilter>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::anime_home::entities::NovelInSearch> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::anime_home::entities::NovelInSearch>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::bridge::NovelViewLog> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::bridge::NovelViewLog>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::anime_home::proto::NovelVolume> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::anime_home::proto::NovelVolume>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::anime_home::proto::NovelVolumeInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::anime_home::proto::NovelVolumeInfo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<i32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <i32>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(String, crate::anime_home::entities::ApiComment)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(String, crate::anime_home::entities::ApiComment)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::anime_home::entities::Subscribed> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::anime_home::entities::Subscribed>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::anime_home::entities::Task> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::anime_home::entities::Task>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::anime_home::entities::TaskList> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::anime_home::entities::TaskList>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for crate::api::bridge::LocalImage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.abs_path, serializer);
        <String>::sse_encode(self.local_path, serializer);
        <String>::sse_encode(self.image_format, serializer);
        <u32>::sse_encode(self.image_width, serializer);
        <u32>::sse_encode(self.image_height, serializer);
    }
}

impl SseEncode for crate::anime_home::entities::LoginData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.uid, serializer);
        <String>::sse_encode(self.nickname, serializer);
        <String>::sse_encode(self.dmzj_token, serializer);
        <String>::sse_encode(self.photo, serializer);
        <String>::sse_encode(self.bind_phone, serializer);
        <String>::sse_encode(self.email, serializer);
        <String>::sse_encode(self.passwd, serializer);
    }
}

impl SseEncode for crate::api::bridge::LoginInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.status, serializer);
        <String>::sse_encode(self.message, serializer);
        <Option<crate::anime_home::entities::LoginData>>::sse_encode(self.data, serializer);
    }
}

impl SseEncode for crate::anime_home::entities::MasterComment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i64>::sse_encode(self.id, serializer);
        <i64>::sse_encode(self.is_passed, serializer);
        <i64>::sse_encode(self.top_status, serializer);
        <i64>::sse_encode(self.is_goods, serializer);
        <String>::sse_encode(self.upload_images, serializer);
        <i64>::sse_encode(self.obj_id, serializer);
        <String>::sse_encode(self.content, serializer);
        <i64>::sse_encode(self.sender_uid, serializer);
        <i64>::sse_encode(self.like_amount, serializer);
        <i64>::sse_encode(self.create_time, serializer);
        <i64>::sse_encode(self.to_uid, serializer);
        <i64>::sse_encode(self.to_comment_id, serializer);
        <i64>::sse_encode(self.origin_comment_id, serializer);
        <i64>::sse_encode(self.reply_amount, serializer);
        <String>::sse_encode(self.cover, serializer);
        <String>::sse_encode(self.nickname, serializer);
        <i64>::sse_encode(self.hot_comment_amount, serializer);
        <i64>::sse_encode(self.sex, serializer);
    }
}

impl SseEncode for crate::anime_home::entities::NewsCategory {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i64>::sse_encode(self.tag_id, serializer);
        <String>::sse_encode(self.tag_name, serializer);
    }
}

impl SseEncode for crate::anime_home::proto::NewsListItem {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.id, serializer);
        <String>::sse_encode(self.title, serializer);
        <String>::sse_encode(self.from_name, serializer);
        <String>::sse_encode(self.from_url, serializer);
        <i64>::sse_encode(self.create_time, serializer);
        <i32>::sse_encode(self.is_foreign, serializer);
        <String>::sse_encode(self.foreign_url, serializer);
        <String>::sse_encode(self.intro, serializer);
        <i32>::sse_encode(self.author_id, serializer);
        <i32>::sse_encode(self.status, serializer);
        <String>::sse_encode(self.row_pic_url, serializer);
        <String>::sse_encode(self.col_pic_url, serializer);
        <i32>::sse_encode(self.q_chat_show, serializer);
        <String>::sse_encode(self.page_url, serializer);
        <i32>::sse_encode(self.comment_amount, serializer);
        <i32>::sse_encode(self.author_uid, serializer);
        <String>::sse_encode(self.cover, serializer);
        <String>::sse_encode(self.nickname, serializer);
        <i32>::sse_encode(self.mood_amount, serializer);
    }
}

impl SseEncode for crate::anime_home::entities::NovelCategory {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i64>::sse_encode(self.tag_id, serializer);
        <String>::sse_encode(self.title, serializer);
        <String>::sse_encode(self.cover, serializer);
    }
}

impl SseEncode for crate::anime_home::proto::NovelChapter {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.chapter_id, serializer);
        <String>::sse_encode(self.chapter_name, serializer);
        <i32>::sse_encode(self.chapter_order, serializer);
    }
}

impl SseEncode for crate::anime_home::proto::NovelDetail {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.id, serializer);
        <String>::sse_encode(self.name, serializer);
        <String>::sse_encode(self.zone, serializer);
        <String>::sse_encode(self.status, serializer);
        <String>::sse_encode(self.last_update_volume_name, serializer);
        <String>::sse_encode(self.last_update_chapter_name, serializer);
        <i32>::sse_encode(self.last_update_volume_id, serializer);
        <i32>::sse_encode(self.last_update_chapter_id, serializer);
        <i64>::sse_encode(self.last_update_time, serializer);
        <String>::sse_encode(self.cover, serializer);
        <i32>::sse_encode(self.hot_hits, serializer);
        <String>::sse_encode(self.introduction, serializer);
        <Vec<String>>::sse_encode(self.types, serializer);
        <String>::sse_encode(self.authors, serializer);
        <String>::sse_encode(self.first_letter, serializer);
        <i32>::sse_encode(self.subscribe_num, serializer);
        <i64>::sse_encode(self.redis_update_time, serializer);
        <Vec<crate::anime_home::proto::NovelVolumeInfo>>::sse_encode(self.volumes, serializer);
    }
}

impl SseEncode for crate::anime_home::entities::NovelInFilter {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.cover, serializer);
        <String>::sse_encode(self.name, serializer);
        <String>::sse_encode(self.authors, serializer);
        <i64>::sse_encode(self.id, serializer);
    }
}

impl SseEncode for crate::anime_home::entities::NovelInSearch {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.biz, serializer);
        <i64>::sse_encode(self.addtime, serializer);
        <String>::sse_encode(self.authors, serializer);
        <i64>::sse_encode(self.copyright, serializer);
        <String>::sse_encode(self.cover, serializer);
        <i64>::sse_encode(self.hidden, serializer);
        <i64>::sse_encode(self.hot_hits, serializer);
        <String>::sse_encode(self.last_name, serializer);
        <i64>::sse_encode(self.status, serializer);
        <String>::sse_encode(self.title, serializer);
        <String>::sse_encode(self.types, serializer);
        <i64>::sse_encode(self.id, serializer);
    }
}

impl SseEncode for crate::api::bridge::NovelViewLog {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.novel_id, serializer);
        <String>::sse_encode(self.novel_title, serializer);
        <String>::sse_encode(self.novel_zone, serializer);
        <String>::sse_encode(self.novel_status, serializer);
        <String>::sse_encode(self.novel_last_update_volume_name, serializer);
        <String>::sse_encode(self.novel_last_update_chapter_name, serializer);
        <i32>::sse_encode(self.novel_last_update_volume_id, serializer);
        <i32>::sse_encode(self.novel_last_update_chapter_id, serializer);
        <i64>::sse_encode(self.novel_last_update_time, serializer);
        <String>::sse_encode(self.novel_cover, serializer);
        <i32>::sse_encode(self.novel_hot_hits, serializer);
        <String>::sse_encode(self.novel_introduction, serializer);
        <String>::sse_encode(self.novel_types, serializer);
        <String>::sse_encode(self.novel_authors, serializer);
        <String>::sse_encode(self.novel_first_letter, serializer);
        <i32>::sse_encode(self.novel_subscribe_num, serializer);
        <i64>::sse_encode(self.novel_redis_update_time, serializer);
        <i32>::sse_encode(self.volume_id, serializer);
        <String>::sse_encode(self.volume_title, serializer);
        <i32>::sse_encode(self.volume_order, serializer);
        <i32>::sse_encode(self.chapter_id, serializer);
        <String>::sse_encode(self.chapter_title, serializer);
        <i32>::sse_encode(self.chapter_order, serializer);
        <i64>::sse_encode(self.progress, serializer);
        <i64>::sse_encode(self.view_time, serializer);
    }
}

impl SseEncode for crate::anime_home::proto::NovelVolume {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.id, serializer);
        <String>::sse_encode(self.title, serializer);
        <i32>::sse_encode(self.rank, serializer);
        <Vec<crate::anime_home::proto::NovelChapter>>::sse_encode(self.chapters, serializer);
    }
}

impl SseEncode for crate::anime_home::proto::NovelVolumeInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.id, serializer);
        <i32>::sse_encode(self.novel_id, serializer);
        <String>::sse_encode(self.title, serializer);
        <i32>::sse_encode(self.rank, serializer);
        <i64>::sse_encode(self.add_time, serializer);
        <i32>::sse_encode(self.chapters_count, serializer);
    }
}

impl SseEncode for Option<crate::api::bridge::ComicViewLog> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::bridge::ComicViewLog>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<i32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <i32>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::anime_home::entities::LoginData> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::anime_home::entities::LoginData>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::bridge::NovelViewLog> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::bridge::NovelViewLog>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for (String, crate::anime_home::entities::ApiComment) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.0, serializer);
        <crate::anime_home::entities::ApiComment>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for crate::anime_home::entities::Subscribed {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.name, serializer);
        <String>::sse_encode(self.sub_update, serializer);
        <String>::sse_encode(self.sub_img, serializer);
        <i64>::sse_encode(self.sub_uptime, serializer);
        <String>::sse_encode(self.sub_first_letter, serializer);
        <i64>::sse_encode(self.sub_readed, serializer);
        <i64>::sse_encode(self.id, serializer);
        <String>::sse_encode(self.status, serializer);
    }
}

impl SseEncode for crate::anime_home::entities::SummationsTask {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i64>::sse_encode(self.sign_count, serializer);
        <i64>::sse_encode(self.max_sign_count, serializer);
        <Vec<crate::anime_home::entities::TaskList>>::sse_encode(self.task_list, serializer);
    }
}

impl SseEncode for crate::anime_home::entities::Task {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i64>::sse_encode(self.id, serializer);
        <String>::sse_encode(self.title, serializer);
        <String>::sse_encode(self.con, serializer);
        <String>::sse_encode(self.icon, serializer);
        <i64>::sse_encode(self.times, serializer);
        <i64>::sse_encode(self.nums, serializer);
        <i64>::sse_encode(self.source, serializer);
        <i64>::sse_encode(self.type_id, serializer);
        <String>::sse_encode(self.url, serializer);
        <String>::sse_encode(self.btn, serializer);
        <i64>::sse_encode(self.status, serializer);
        <i64>::sse_encode(self.progress, serializer);
    }
}

impl SseEncode for crate::anime_home::entities::TaskIndex {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<crate::anime_home::entities::Task>>::sse_encode(self.new_person_task, serializer);
        <Vec<crate::anime_home::entities::Task>>::sse_encode(self.day_task, serializer);
        <Vec<crate::anime_home::entities::Task>>::sse_encode(self.week_task, serializer);
        <crate::anime_home::entities::SummationsTask>::sse_encode(self.summations_task, serializer);
        <crate::anime_home::entities::DaySignTask>::sse_encode(self.day_sign_task, serializer);
        <i64>::sse_encode(self.credits_nums, serializer);
        <i64>::sse_encode(self.silver_nums, serializer);
        <i64>::sse_encode(self.stars_nums, serializer);
    }
}

impl SseEncode for crate::anime_home::entities::TaskList {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i64>::sse_encode(self.id, serializer);
        <String>::sse_encode(self.title, serializer);
        <String>::sse_encode(self.con, serializer);
        <String>::sse_encode(self.icon, serializer);
        <i64>::sse_encode(self.times, serializer);
        <i64>::sse_encode(self.nums, serializer);
        <i64>::sse_encode(self.source, serializer);
        <i64>::sse_encode(self.type_id, serializer);
        <String>::sse_encode(self.url, serializer);
        <String>::sse_encode(self.btn, serializer);
        <i64>::sse_encode(self.status, serializer);
        <i64>::sse_encode(self.progress, serializer);
        <String>::sse_encode(self.icon_checked, serializer);
    }
}

impl SseEncode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self).unwrap();
    }
}

impl SseEncode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

#[cfg(not(target_family = "wasm"))]
mod io {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.9.0.

    // Section: imports

    use super::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_io!();
}
#[cfg(not(target_family = "wasm"))]
pub use io::*;

/// cbindgen:ignore
#[cfg(target_family = "wasm")]
mod web {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.9.0.

    // Section: imports

    use super::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::wasm_bindgen;
    use flutter_rust_bridge::for_generated::wasm_bindgen::prelude::*;
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_web!();
}
#[cfg(target_family = "wasm")]
pub use web::*;
