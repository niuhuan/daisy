// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'anime_home/entities.dart';
import 'anime_home/proto.dart';
import 'api/bridge.dart';
import 'api/simple.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'frb_generated.io.dart'
    if (dart.library.js_interop) 'frb_generated.web.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    RustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
    );
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({
    required RustLibApi api,
  }) {
    instance.initMockImpl(
      api: api,
    );
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor =>
      RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor =>
      RustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {
    await api.crateApiSimpleInitApp();
  }

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.9.0';

  @override
  int get rustContentHash => 1961467821;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
    stem: 'rust_lib_daisy',
    ioDirectory: 'rust/target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class RustLibApi extends BaseApi {
  Future<List<DownloadComic>> crateApiBridgeAllDownloads();

  Future<void> crateApiBridgeAutoClean({required PlatformInt64 time});

  Future<List<ComicCategory>> crateApiBridgeComicCategories();

  Future<ComicChapterDetail> crateApiBridgeComicChapterDetail(
      {required int comicId, required int chapterId});

  Future<List<ComicFilter>> crateApiBridgeComicClassifyFilters();

  Future<List<ComicFilter>> crateApiBridgeComicClassifyFiltersOld();

  Future<List<ComicInFilter>> crateApiBridgeComicClassifyWithLevel(
      {required List<int> categories,
      required PlatformInt64 sort,
      required PlatformInt64 page});

  Future<ComicDetail> crateApiBridgeComicDetail({required int id});

  Future<List<ComicRankListItem>> crateApiBridgeComicRankList();

  Future<List<ComicInFilter>> crateApiBridgeComicRecommend();

  Future<List<ComicInSearch>> crateApiBridgeComicSearch(
      {required String content, required PlatformInt64 page});

  Future<List<ComicUpdateListItem>> crateApiBridgeComicUpdateList(
      {required PlatformInt64 sort, required PlatformInt64 page});

  Future<void> crateApiBridgeComicViewPage(
      {required int comicId,
      required int chapterId,
      required String chapterTitle,
      required int chapterOrder,
      required int pageRank});

  Future<List<Comment>> crateApiBridgeComment(
      {required PlatformInt64 objType,
      required int objId,
      required bool hot,
      required PlatformInt64 page});

  Future<String> crateApiBridgeCreateDownload({required ComicDetail buff});

  Future<String> crateApiBridgeDeleteDownload({required int id});

  Future<String> crateApiBridgeDesktopRoot();

  Future<List<ComicChapter>> crateApiBridgeDownloadComicChaptersByComicId(
      {required int id});

  Future<List<String>> crateApiBridgeDownloadComicPageByChapterId(
      {required int chapterId});

  String crateApiSimpleGreet({required String name});

  Future<String> crateApiBridgeHttpGet({required String url});

  Future<void> crateApiBridgeInit({required String root});

  Future<void> crateApiSimpleInitApp();

  Future<LocalImage> crateApiBridgeLoadCacheImage(
      {required String url,
      required String useful,
      int? extendsFieldIntFirst,
      int? extendsFieldIntSecond,
      int? extendsFieldIntThird});

  Future<int> crateApiBridgeLoadComicId({required String comicIdString});

  Future<List<ComicViewLog>> crateApiBridgeLoadComicViewLogs(
      {required PlatformInt64 page});

  Future<List<NovelViewLog>> crateApiBridgeLoadNovelViewLogs(
      {required PlatformInt64 page});

  Future<String> crateApiBridgeLoadProperty({required String k});

  Future<List<NewsCategory>> crateApiBridgeNewsCategories();

  Future<List<NewsListItem>> crateApiBridgeNewsList(
      {required PlatformInt64 id, required PlatformInt64 page});

  Future<List<NovelCategory>> crateApiBridgeNovelCategories();

  Future<List<NovelVolume>> crateApiBridgeNovelChapters({required int id});

  Future<String> crateApiBridgeNovelContent(
      {required int volumeId, required int chapterId});

  Future<NovelDetail> crateApiBridgeNovelDetail({required int id});

  Future<List<NovelInFilter>> crateApiBridgeNovelList(
      {required int category,
      required PlatformInt64 process,
      required PlatformInt64 sort,
      required PlatformInt64 page});

  Future<List<NovelInSearch>> crateApiBridgeNovelSearch(
      {required String content, required PlatformInt64 page});

  Future<void> crateApiBridgeNovelViewPage(
      {required int novelId,
      required int volumeId,
      required String volumeTitle,
      required int volumeOrder,
      required int chapterId,
      required String chapterTitle,
      required int chapterOrder,
      required PlatformInt64 progress});

  Future<LoginInfo> crateApiBridgePreLogin(
      {required String nickname, required String passwd});

  Future<LoginInfo> crateApiBridgeReLogin(
      {required String nickname, required String passwd});

  Future<String> crateApiBridgeRenewAllDownloads();

  Future<void> crateApiBridgeSaveProperty(
      {required String k, required String v});

  Future<void> crateApiBridgeSubscribeAdd(
      {required String objType, required int objId});

  Future<void> crateApiBridgeSubscribeCancel(
      {required String objType, required int objId});

  Future<List<Subscribed>> crateApiBridgeSubscribedList(
      {required PlatformInt64 subType, required PlatformInt64 page});

  Future<bool> crateApiBridgeSubscribedObj(
      {required PlatformInt64 subType, required int objId});

  Future<TaskIndex> crateApiBridgeTaskIndex();

  Future<void> crateApiBridgeTaskSign();

  Future<ComicViewLog?> crateApiBridgeViewLogByComicId({required int comicId});

  Future<NovelViewLog?> crateApiBridgeViewLogByNovelId({required int novelId});
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<List<DownloadComic>> crateApiBridgeAllDownloads() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 1, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_download_comic,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBridgeAllDownloadsConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBridgeAllDownloadsConstMeta => const TaskConstMeta(
        debugName: "all_downloads",
        argNames: [],
      );

  @override
  Future<void> crateApiBridgeAutoClean({required PlatformInt64 time}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_i_64(time, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 2, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBridgeAutoCleanConstMeta,
      argValues: [time],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBridgeAutoCleanConstMeta => const TaskConstMeta(
        debugName: "auto_clean",
        argNames: ["time"],
      );

  @override
  Future<List<ComicCategory>> crateApiBridgeComicCategories() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 3, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_comic_category,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBridgeComicCategoriesConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBridgeComicCategoriesConstMeta =>
      const TaskConstMeta(
        debugName: "comic_categories",
        argNames: [],
      );

  @override
  Future<ComicChapterDetail> crateApiBridgeComicChapterDetail(
      {required int comicId, required int chapterId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_i_32(comicId, serializer);
        sse_encode_i_32(chapterId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 4, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_comic_chapter_detail,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBridgeComicChapterDetailConstMeta,
      argValues: [comicId, chapterId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBridgeComicChapterDetailConstMeta =>
      const TaskConstMeta(
        debugName: "comic_chapter_detail",
        argNames: ["comicId", "chapterId"],
      );

  @override
  Future<List<ComicFilter>> crateApiBridgeComicClassifyFilters() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 5, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_comic_filter,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBridgeComicClassifyFiltersConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBridgeComicClassifyFiltersConstMeta =>
      const TaskConstMeta(
        debugName: "comic_classify_filters",
        argNames: [],
      );

  @override
  Future<List<ComicFilter>> crateApiBridgeComicClassifyFiltersOld() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 6, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_comic_filter,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBridgeComicClassifyFiltersOldConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBridgeComicClassifyFiltersOldConstMeta =>
      const TaskConstMeta(
        debugName: "comic_classify_filters_old",
        argNames: [],
      );

  @override
  Future<List<ComicInFilter>> crateApiBridgeComicClassifyWithLevel(
      {required List<int> categories,
      required PlatformInt64 sort,
      required PlatformInt64 page}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_list_prim_i_32_loose(categories, serializer);
        sse_encode_i_64(sort, serializer);
        sse_encode_i_64(page, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 7, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_comic_in_filter,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBridgeComicClassifyWithLevelConstMeta,
      argValues: [categories, sort, page],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBridgeComicClassifyWithLevelConstMeta =>
      const TaskConstMeta(
        debugName: "comic_classify_with_level",
        argNames: ["categories", "sort", "page"],
      );

  @override
  Future<ComicDetail> crateApiBridgeComicDetail({required int id}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_i_32(id, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 8, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_comic_detail,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBridgeComicDetailConstMeta,
      argValues: [id],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBridgeComicDetailConstMeta => const TaskConstMeta(
        debugName: "comic_detail",
        argNames: ["id"],
      );

  @override
  Future<List<ComicRankListItem>> crateApiBridgeComicRankList() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 9, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_comic_rank_list_item,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBridgeComicRankListConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBridgeComicRankListConstMeta =>
      const TaskConstMeta(
        debugName: "comic_rank_list",
        argNames: [],
      );

  @override
  Future<List<ComicInFilter>> crateApiBridgeComicRecommend() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 10, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_comic_in_filter,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBridgeComicRecommendConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBridgeComicRecommendConstMeta =>
      const TaskConstMeta(
        debugName: "comic_recommend",
        argNames: [],
      );

  @override
  Future<List<ComicInSearch>> crateApiBridgeComicSearch(
      {required String content, required PlatformInt64 page}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(content, serializer);
        sse_encode_i_64(page, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 11, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_comic_in_search,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBridgeComicSearchConstMeta,
      argValues: [content, page],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBridgeComicSearchConstMeta => const TaskConstMeta(
        debugName: "comic_search",
        argNames: ["content", "page"],
      );

  @override
  Future<List<ComicUpdateListItem>> crateApiBridgeComicUpdateList(
      {required PlatformInt64 sort, required PlatformInt64 page}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_i_64(sort, serializer);
        sse_encode_i_64(page, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 12, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_comic_update_list_item,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBridgeComicUpdateListConstMeta,
      argValues: [sort, page],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBridgeComicUpdateListConstMeta =>
      const TaskConstMeta(
        debugName: "comic_update_list",
        argNames: ["sort", "page"],
      );

  @override
  Future<void> crateApiBridgeComicViewPage(
      {required int comicId,
      required int chapterId,
      required String chapterTitle,
      required int chapterOrder,
      required int pageRank}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_i_32(comicId, serializer);
        sse_encode_i_32(chapterId, serializer);
        sse_encode_String(chapterTitle, serializer);
        sse_encode_i_32(chapterOrder, serializer);
        sse_encode_i_32(pageRank, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 13, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBridgeComicViewPageConstMeta,
      argValues: [comicId, chapterId, chapterTitle, chapterOrder, pageRank],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBridgeComicViewPageConstMeta =>
      const TaskConstMeta(
        debugName: "comic_view_page",
        argNames: [
          "comicId",
          "chapterId",
          "chapterTitle",
          "chapterOrder",
          "pageRank"
        ],
      );

  @override
  Future<List<Comment>> crateApiBridgeComment(
      {required PlatformInt64 objType,
      required int objId,
      required bool hot,
      required PlatformInt64 page}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_i_64(objType, serializer);
        sse_encode_i_32(objId, serializer);
        sse_encode_bool(hot, serializer);
        sse_encode_i_64(page, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 14, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_comment,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBridgeCommentConstMeta,
      argValues: [objType, objId, hot, page],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBridgeCommentConstMeta => const TaskConstMeta(
        debugName: "comment",
        argNames: ["objType", "objId", "hot", "page"],
      );

  @override
  Future<String> crateApiBridgeCreateDownload({required ComicDetail buff}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_comic_detail(buff, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 15, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBridgeCreateDownloadConstMeta,
      argValues: [buff],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBridgeCreateDownloadConstMeta =>
      const TaskConstMeta(
        debugName: "create_download",
        argNames: ["buff"],
      );

  @override
  Future<String> crateApiBridgeDeleteDownload({required int id}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_i_32(id, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 16, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBridgeDeleteDownloadConstMeta,
      argValues: [id],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBridgeDeleteDownloadConstMeta =>
      const TaskConstMeta(
        debugName: "delete_download",
        argNames: ["id"],
      );

  @override
  Future<String> crateApiBridgeDesktopRoot() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 17, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBridgeDesktopRootConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBridgeDesktopRootConstMeta => const TaskConstMeta(
        debugName: "desktop_root",
        argNames: [],
      );

  @override
  Future<List<ComicChapter>> crateApiBridgeDownloadComicChaptersByComicId(
      {required int id}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_i_32(id, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 18, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_comic_chapter,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBridgeDownloadComicChaptersByComicIdConstMeta,
      argValues: [id],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBridgeDownloadComicChaptersByComicIdConstMeta =>
      const TaskConstMeta(
        debugName: "download_comic_chapters_by_comic_id",
        argNames: ["id"],
      );

  @override
  Future<List<String>> crateApiBridgeDownloadComicPageByChapterId(
      {required int chapterId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_i_32(chapterId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 19, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBridgeDownloadComicPageByChapterIdConstMeta,
      argValues: [chapterId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBridgeDownloadComicPageByChapterIdConstMeta =>
      const TaskConstMeta(
        debugName: "download_comic_page_by_chapter_id",
        argNames: ["chapterId"],
      );

  @override
  String crateApiSimpleGreet({required String name}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(name, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 20)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSimpleGreetConstMeta,
      argValues: [name],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleGreetConstMeta => const TaskConstMeta(
        debugName: "greet",
        argNames: ["name"],
      );

  @override
  Future<String> crateApiBridgeHttpGet({required String url}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(url, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 21, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBridgeHttpGetConstMeta,
      argValues: [url],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBridgeHttpGetConstMeta => const TaskConstMeta(
        debugName: "http_get",
        argNames: ["url"],
      );

  @override
  Future<void> crateApiBridgeInit({required String root}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(root, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 22, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiBridgeInitConstMeta,
      argValues: [root],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBridgeInitConstMeta => const TaskConstMeta(
        debugName: "init",
        argNames: ["root"],
      );

  @override
  Future<void> crateApiSimpleInitApp() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 23, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSimpleInitAppConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleInitAppConstMeta => const TaskConstMeta(
        debugName: "init_app",
        argNames: [],
      );

  @override
  Future<LocalImage> crateApiBridgeLoadCacheImage(
      {required String url,
      required String useful,
      int? extendsFieldIntFirst,
      int? extendsFieldIntSecond,
      int? extendsFieldIntThird}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(url, serializer);
        sse_encode_String(useful, serializer);
        sse_encode_opt_box_autoadd_i_32(extendsFieldIntFirst, serializer);
        sse_encode_opt_box_autoadd_i_32(extendsFieldIntSecond, serializer);
        sse_encode_opt_box_autoadd_i_32(extendsFieldIntThird, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 24, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_local_image,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBridgeLoadCacheImageConstMeta,
      argValues: [
        url,
        useful,
        extendsFieldIntFirst,
        extendsFieldIntSecond,
        extendsFieldIntThird
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBridgeLoadCacheImageConstMeta =>
      const TaskConstMeta(
        debugName: "load_cache_image",
        argNames: [
          "url",
          "useful",
          "extendsFieldIntFirst",
          "extendsFieldIntSecond",
          "extendsFieldIntThird"
        ],
      );

  @override
  Future<int> crateApiBridgeLoadComicId({required String comicIdString}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(comicIdString, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 25, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_32,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBridgeLoadComicIdConstMeta,
      argValues: [comicIdString],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBridgeLoadComicIdConstMeta => const TaskConstMeta(
        debugName: "load_comic_id",
        argNames: ["comicIdString"],
      );

  @override
  Future<List<ComicViewLog>> crateApiBridgeLoadComicViewLogs(
      {required PlatformInt64 page}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_i_64(page, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 26, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_comic_view_log,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBridgeLoadComicViewLogsConstMeta,
      argValues: [page],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBridgeLoadComicViewLogsConstMeta =>
      const TaskConstMeta(
        debugName: "load_comic_view_logs",
        argNames: ["page"],
      );

  @override
  Future<List<NovelViewLog>> crateApiBridgeLoadNovelViewLogs(
      {required PlatformInt64 page}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_i_64(page, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 27, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_novel_view_log,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBridgeLoadNovelViewLogsConstMeta,
      argValues: [page],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBridgeLoadNovelViewLogsConstMeta =>
      const TaskConstMeta(
        debugName: "load_novel_view_logs",
        argNames: ["page"],
      );

  @override
  Future<String> crateApiBridgeLoadProperty({required String k}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(k, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 28, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBridgeLoadPropertyConstMeta,
      argValues: [k],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBridgeLoadPropertyConstMeta => const TaskConstMeta(
        debugName: "load_property",
        argNames: ["k"],
      );

  @override
  Future<List<NewsCategory>> crateApiBridgeNewsCategories() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 29, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_news_category,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBridgeNewsCategoriesConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBridgeNewsCategoriesConstMeta =>
      const TaskConstMeta(
        debugName: "news_categories",
        argNames: [],
      );

  @override
  Future<List<NewsListItem>> crateApiBridgeNewsList(
      {required PlatformInt64 id, required PlatformInt64 page}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_i_64(id, serializer);
        sse_encode_i_64(page, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 30, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_news_list_item,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBridgeNewsListConstMeta,
      argValues: [id, page],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBridgeNewsListConstMeta => const TaskConstMeta(
        debugName: "news_list",
        argNames: ["id", "page"],
      );

  @override
  Future<List<NovelCategory>> crateApiBridgeNovelCategories() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 31, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_novel_category,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBridgeNovelCategoriesConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBridgeNovelCategoriesConstMeta =>
      const TaskConstMeta(
        debugName: "novel_categories",
        argNames: [],
      );

  @override
  Future<List<NovelVolume>> crateApiBridgeNovelChapters({required int id}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_i_32(id, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 32, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_novel_volume,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBridgeNovelChaptersConstMeta,
      argValues: [id],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBridgeNovelChaptersConstMeta =>
      const TaskConstMeta(
        debugName: "novel_chapters",
        argNames: ["id"],
      );

  @override
  Future<String> crateApiBridgeNovelContent(
      {required int volumeId, required int chapterId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_i_32(volumeId, serializer);
        sse_encode_i_32(chapterId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 33, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBridgeNovelContentConstMeta,
      argValues: [volumeId, chapterId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBridgeNovelContentConstMeta => const TaskConstMeta(
        debugName: "novel_content",
        argNames: ["volumeId", "chapterId"],
      );

  @override
  Future<NovelDetail> crateApiBridgeNovelDetail({required int id}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_i_32(id, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 34, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_novel_detail,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBridgeNovelDetailConstMeta,
      argValues: [id],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBridgeNovelDetailConstMeta => const TaskConstMeta(
        debugName: "novel_detail",
        argNames: ["id"],
      );

  @override
  Future<List<NovelInFilter>> crateApiBridgeNovelList(
      {required int category,
      required PlatformInt64 process,
      required PlatformInt64 sort,
      required PlatformInt64 page}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_i_32(category, serializer);
        sse_encode_i_64(process, serializer);
        sse_encode_i_64(sort, serializer);
        sse_encode_i_64(page, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 35, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_novel_in_filter,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBridgeNovelListConstMeta,
      argValues: [category, process, sort, page],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBridgeNovelListConstMeta => const TaskConstMeta(
        debugName: "novel_list",
        argNames: ["category", "process", "sort", "page"],
      );

  @override
  Future<List<NovelInSearch>> crateApiBridgeNovelSearch(
      {required String content, required PlatformInt64 page}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(content, serializer);
        sse_encode_i_64(page, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 36, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_novel_in_search,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBridgeNovelSearchConstMeta,
      argValues: [content, page],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBridgeNovelSearchConstMeta => const TaskConstMeta(
        debugName: "novel_search",
        argNames: ["content", "page"],
      );

  @override
  Future<void> crateApiBridgeNovelViewPage(
      {required int novelId,
      required int volumeId,
      required String volumeTitle,
      required int volumeOrder,
      required int chapterId,
      required String chapterTitle,
      required int chapterOrder,
      required PlatformInt64 progress}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_i_32(novelId, serializer);
        sse_encode_i_32(volumeId, serializer);
        sse_encode_String(volumeTitle, serializer);
        sse_encode_i_32(volumeOrder, serializer);
        sse_encode_i_32(chapterId, serializer);
        sse_encode_String(chapterTitle, serializer);
        sse_encode_i_32(chapterOrder, serializer);
        sse_encode_i_64(progress, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 37, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBridgeNovelViewPageConstMeta,
      argValues: [
        novelId,
        volumeId,
        volumeTitle,
        volumeOrder,
        chapterId,
        chapterTitle,
        chapterOrder,
        progress
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBridgeNovelViewPageConstMeta =>
      const TaskConstMeta(
        debugName: "novel_view_page",
        argNames: [
          "novelId",
          "volumeId",
          "volumeTitle",
          "volumeOrder",
          "chapterId",
          "chapterTitle",
          "chapterOrder",
          "progress"
        ],
      );

  @override
  Future<LoginInfo> crateApiBridgePreLogin(
      {required String nickname, required String passwd}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(nickname, serializer);
        sse_encode_String(passwd, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 38, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_login_info,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiBridgePreLoginConstMeta,
      argValues: [nickname, passwd],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBridgePreLoginConstMeta => const TaskConstMeta(
        debugName: "pre_login",
        argNames: ["nickname", "passwd"],
      );

  @override
  Future<LoginInfo> crateApiBridgeReLogin(
      {required String nickname, required String passwd}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(nickname, serializer);
        sse_encode_String(passwd, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 39, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_login_info,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiBridgeReLoginConstMeta,
      argValues: [nickname, passwd],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBridgeReLoginConstMeta => const TaskConstMeta(
        debugName: "re_login",
        argNames: ["nickname", "passwd"],
      );

  @override
  Future<String> crateApiBridgeRenewAllDownloads() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 40, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBridgeRenewAllDownloadsConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBridgeRenewAllDownloadsConstMeta =>
      const TaskConstMeta(
        debugName: "renew_all_downloads",
        argNames: [],
      );

  @override
  Future<void> crateApiBridgeSaveProperty(
      {required String k, required String v}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(k, serializer);
        sse_encode_String(v, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 41, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBridgeSavePropertyConstMeta,
      argValues: [k, v],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBridgeSavePropertyConstMeta => const TaskConstMeta(
        debugName: "save_property",
        argNames: ["k", "v"],
      );

  @override
  Future<void> crateApiBridgeSubscribeAdd(
      {required String objType, required int objId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(objType, serializer);
        sse_encode_i_32(objId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 42, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBridgeSubscribeAddConstMeta,
      argValues: [objType, objId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBridgeSubscribeAddConstMeta => const TaskConstMeta(
        debugName: "subscribe_add",
        argNames: ["objType", "objId"],
      );

  @override
  Future<void> crateApiBridgeSubscribeCancel(
      {required String objType, required int objId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(objType, serializer);
        sse_encode_i_32(objId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 43, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBridgeSubscribeCancelConstMeta,
      argValues: [objType, objId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBridgeSubscribeCancelConstMeta =>
      const TaskConstMeta(
        debugName: "subscribe_cancel",
        argNames: ["objType", "objId"],
      );

  @override
  Future<List<Subscribed>> crateApiBridgeSubscribedList(
      {required PlatformInt64 subType, required PlatformInt64 page}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_i_64(subType, serializer);
        sse_encode_i_64(page, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 44, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_subscribed,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBridgeSubscribedListConstMeta,
      argValues: [subType, page],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBridgeSubscribedListConstMeta =>
      const TaskConstMeta(
        debugName: "subscribed_list",
        argNames: ["subType", "page"],
      );

  @override
  Future<bool> crateApiBridgeSubscribedObj(
      {required PlatformInt64 subType, required int objId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_i_64(subType, serializer);
        sse_encode_i_32(objId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 45, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBridgeSubscribedObjConstMeta,
      argValues: [subType, objId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBridgeSubscribedObjConstMeta =>
      const TaskConstMeta(
        debugName: "subscribed_obj",
        argNames: ["subType", "objId"],
      );

  @override
  Future<TaskIndex> crateApiBridgeTaskIndex() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 46, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_task_index,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBridgeTaskIndexConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBridgeTaskIndexConstMeta => const TaskConstMeta(
        debugName: "task_index",
        argNames: [],
      );

  @override
  Future<void> crateApiBridgeTaskSign() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 47, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBridgeTaskSignConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBridgeTaskSignConstMeta => const TaskConstMeta(
        debugName: "task_sign",
        argNames: [],
      );

  @override
  Future<ComicViewLog?> crateApiBridgeViewLogByComicId({required int comicId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_i_32(comicId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 48, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_comic_view_log,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBridgeViewLogByComicIdConstMeta,
      argValues: [comicId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBridgeViewLogByComicIdConstMeta =>
      const TaskConstMeta(
        debugName: "view_log_by_comic_id",
        argNames: ["comicId"],
      );

  @override
  Future<NovelViewLog?> crateApiBridgeViewLogByNovelId({required int novelId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_i_32(novelId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 49, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_novel_view_log,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBridgeViewLogByNovelIdConstMeta,
      argValues: [novelId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBridgeViewLogByNovelIdConstMeta =>
      const TaskConstMeta(
        debugName: "view_log_by_novel_id",
        argNames: ["novelId"],
      );

  @protected
  AnyhowException dco_decode_AnyhowException(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnyhowException(raw as String);
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  ComicDetail dco_decode_box_autoadd_comic_detail(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_comic_detail(raw);
  }

  @protected
  ComicViewLog dco_decode_box_autoadd_comic_view_log(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_comic_view_log(raw);
  }

  @protected
  int dco_decode_box_autoadd_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  LoginData dco_decode_box_autoadd_login_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_login_data(raw);
  }

  @protected
  NovelViewLog dco_decode_box_autoadd_novel_view_log(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_novel_view_log(raw);
  }

  @protected
  ComicCategory dco_decode_comic_category(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return ComicCategory(
      tagId: dco_decode_i_32(arr[0]),
      title: dco_decode_String(arr[1]),
      cover: dco_decode_String(arr[2]),
    );
  }

  @protected
  ComicChapter dco_decode_comic_chapter(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ComicChapter(
      title: dco_decode_String(arr[0]),
      data: dco_decode_list_comic_chapter_info(arr[1]),
    );
  }

  @protected
  ComicChapterDetail dco_decode_comic_chapter_detail(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 9)
      throw Exception('unexpected arr length: expect 9 but see ${arr.length}');
    return ComicChapterDetail(
      chapterId: dco_decode_i_64(arr[0]),
      comicId: dco_decode_i_64(arr[1]),
      title: dco_decode_String(arr[2]),
      chapterOrder: dco_decode_i_32(arr[3]),
      direction: dco_decode_i_32(arr[4]),
      pageUrl: dco_decode_list_String(arr[5]),
      picnum: dco_decode_i_32(arr[6]),
      pageUrlHd: dco_decode_list_String(arr[7]),
      commentCount: dco_decode_i_32(arr[8]),
    );
  }

  @protected
  ComicChapterInfo dco_decode_comic_chapter_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return ComicChapterInfo(
      chapterId: dco_decode_i_32(arr[0]),
      chapterTitle: dco_decode_String(arr[1]),
      updateTime: dco_decode_i_64(arr[2]),
      fileSize: dco_decode_i_32(arr[3]),
      chapterOrder: dco_decode_i_32(arr[4]),
    );
  }

  @protected
  ComicDetail dco_decode_comic_detail(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 25)
      throw Exception('unexpected arr length: expect 25 but see ${arr.length}');
    return ComicDetail(
      id: dco_decode_i_32(arr[0]),
      title: dco_decode_String(arr[1]),
      direction: dco_decode_i_32(arr[2]),
      isLong: dco_decode_i_32(arr[3]),
      isAnimeHome: dco_decode_i_32(arr[4]),
      cover: dco_decode_String(arr[5]),
      description: dco_decode_String(arr[6]),
      lastUpdateTime: dco_decode_i_64(arr[7]),
      lastUpdateChapterName: dco_decode_String(arr[8]),
      copyright: dco_decode_i_32(arr[9]),
      firstLetter: dco_decode_String(arr[10]),
      comicPy: dco_decode_String(arr[11]),
      hidden: dco_decode_i_32(arr[12]),
      hotNum: dco_decode_i_32(arr[13]),
      hitNum: dco_decode_i_32(arr[14]),
      uid: dco_decode_i_32(arr[15]),
      isLock: dco_decode_i_32(arr[16]),
      lastUpdateChapterId: dco_decode_i_32(arr[17]),
      types: dco_decode_list_item(arr[18]),
      status: dco_decode_list_item(arr[19]),
      authors: dco_decode_list_item(arr[20]),
      subscribeNum: dco_decode_i_32(arr[21]),
      chapters: dco_decode_list_comic_chapter(arr[22]),
      isNeedLogin: dco_decode_i_32(arr[23]),
      isHideChapter: dco_decode_i_32(arr[24]),
    );
  }

  @protected
  ComicFilter dco_decode_comic_filter(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ComicFilter(
      title: dco_decode_String(arr[0]),
      items: dco_decode_list_comic_filter_item(arr[1]),
    );
  }

  @protected
  ComicFilterItem dco_decode_comic_filter_item(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ComicFilterItem(
      tagId: dco_decode_i_64(arr[0]),
      tagName: dco_decode_String(arr[1]),
    );
  }

  @protected
  ComicInFilter dco_decode_comic_in_filter(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8)
      throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return ComicInFilter(
      id: dco_decode_i_64(arr[0]),
      title: dco_decode_String(arr[1]),
      authors: dco_decode_String(arr[2]),
      status: dco_decode_String(arr[3]),
      cover: dco_decode_String(arr[4]),
      types: dco_decode_String(arr[5]),
      lastUpdateTime: dco_decode_i_64(arr[6]),
      num: dco_decode_i_64(arr[7]),
    );
  }

  @protected
  ComicInSearch dco_decode_comic_in_search(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 12)
      throw Exception('unexpected arr length: expect 12 but see ${arr.length}');
    return ComicInSearch(
      biz: dco_decode_String(arr[0]),
      addtime: dco_decode_i_64(arr[1]),
      authors: dco_decode_String(arr[2]),
      copyright: dco_decode_i_64(arr[3]),
      cover: dco_decode_String(arr[4]),
      hidden: dco_decode_i_64(arr[5]),
      hotHits: dco_decode_i_64(arr[6]),
      lastName: dco_decode_String(arr[7]),
      status: dco_decode_i_64(arr[8]),
      title: dco_decode_String(arr[9]),
      types: dco_decode_String(arr[10]),
      id: dco_decode_i_64(arr[11]),
    );
  }

  @protected
  ComicRankListItem dco_decode_comic_rank_list_item(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 13)
      throw Exception('unexpected arr length: expect 13 but see ${arr.length}');
    return ComicRankListItem(
      id: dco_decode_i_32(arr[0]),
      title: dco_decode_String(arr[1]),
      authors: dco_decode_String(arr[2]),
      status: dco_decode_String(arr[3]),
      cover: dco_decode_String(arr[4]),
      types: dco_decode_String(arr[5]),
      lastUpdateTime: dco_decode_i_64(arr[6]),
      lastUpdateChapterName: dco_decode_String(arr[7]),
      comicPy: dco_decode_String(arr[8]),
      num: dco_decode_i_32(arr[9]),
      tagId: dco_decode_i_32(arr[10]),
      chapterName: dco_decode_String(arr[11]),
      chapterId: dco_decode_i_32(arr[12]),
    );
  }

  @protected
  ComicUpdateListItem dco_decode_comic_update_list_item(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 10)
      throw Exception('unexpected arr length: expect 10 but see ${arr.length}');
    return ComicUpdateListItem(
      id: dco_decode_i_32(arr[0]),
      title: dco_decode_String(arr[1]),
      isLong: dco_decode_bool(arr[2]),
      authors: dco_decode_String(arr[3]),
      types: dco_decode_String(arr[4]),
      cover: dco_decode_String(arr[5]),
      status: dco_decode_String(arr[6]),
      lastUpdateChapterName: dco_decode_String(arr[7]),
      lastUpdateChapterId: dco_decode_i_32(arr[8]),
      lastUpdateTime: dco_decode_i_64(arr[9]),
    );
  }

  @protected
  ComicViewLog dco_decode_comic_view_log(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 13)
      throw Exception('unexpected arr length: expect 13 but see ${arr.length}');
    return ComicViewLog(
      comicId: dco_decode_i_32(arr[0]),
      comicTitle: dco_decode_String(arr[1]),
      comicAuthors: dco_decode_String(arr[2]),
      comicStatus: dco_decode_String(arr[3]),
      comicCover: dco_decode_String(arr[4]),
      comicTypes: dco_decode_String(arr[5]),
      comicLastUpdateTime: dco_decode_i_64(arr[6]),
      comicLastUpdateChapterName: dco_decode_String(arr[7]),
      chapterId: dco_decode_i_32(arr[8]),
      chapterTitle: dco_decode_String(arr[9]),
      chapterOrder: dco_decode_i_32(arr[10]),
      pageRank: dco_decode_i_32(arr[11]),
      viewTime: dco_decode_i_64(arr[12]),
    );
  }

  @protected
  Comment dco_decode_comment(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 21)
      throw Exception('unexpected arr length: expect 21 but see ${arr.length}');
    return Comment(
      id: dco_decode_i_64(arr[0]),
      isPassed: dco_decode_i_64(arr[1]),
      topStatus: dco_decode_i_64(arr[2]),
      isGoods: dco_decode_i_64(arr[3]),
      uploadImages: dco_decode_String(arr[4]),
      objId: dco_decode_i_64(arr[5]),
      content: dco_decode_String(arr[6]),
      senderUid: dco_decode_i_64(arr[7]),
      likeAmount: dco_decode_i_64(arr[8]),
      createTime: dco_decode_i_64(arr[9]),
      toUid: dco_decode_i_64(arr[10]),
      toCommentId: dco_decode_i_64(arr[11]),
      originCommentId: dco_decode_i_64(arr[12]),
      replyAmount: dco_decode_i_64(arr[13]),
      hotCommentAmount: dco_decode_i_64(arr[14]),
      cover: dco_decode_String(arr[15]),
      nickname: dco_decode_String(arr[16]),
      avatarUrl: dco_decode_String(arr[17]),
      sex: dco_decode_i_64(arr[18]),
      masterCommentNum: dco_decode_i_64(arr[19]),
      masterComment: dco_decode_list_master_comment(arr[20]),
    );
  }

  @protected
  DayList dco_decode_day_list(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8)
      throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return DayList(
      id: dco_decode_i_64(arr[0]),
      title: dco_decode_String(arr[1]),
      icon: dco_decode_String(arr[2]),
      iconChecked: dco_decode_String(arr[3]),
      typeId: dco_decode_i_64(arr[4]),
      times: dco_decode_i_64(arr[5]),
      nums: dco_decode_i_64(arr[6]),
      creditsNums: dco_decode_i_64(arr[7]),
    );
  }

  @protected
  DaySignTask dco_decode_day_sign_task(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return DaySignTask(
      currentDay: dco_decode_i_64(arr[0]),
      status: dco_decode_i_64(arr[1]),
      doubleStatus: dco_decode_i_64(arr[2]),
      dayList: dco_decode_list_day_list(arr[3]),
    );
  }

  @protected
  DownloadComic dco_decode_download_comic(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 20)
      throw Exception('unexpected arr length: expect 20 but see ${arr.length}');
    return DownloadComic(
      id: dco_decode_i_32(arr[0]),
      title: dco_decode_String(arr[1]),
      authors: dco_decode_String(arr[2]),
      types: dco_decode_String(arr[3]),
      status: dco_decode_String(arr[4]),
      direction: dco_decode_i_32(arr[5]),
      isLong: dco_decode_i_32(arr[6]),
      isAnimeHome: dco_decode_i_32(arr[7]),
      cover: dco_decode_String(arr[8]),
      description: dco_decode_String(arr[9]),
      copyright: dco_decode_i_32(arr[10]),
      firstLetter: dco_decode_String(arr[11]),
      comicPy: dco_decode_String(arr[12]),
      coverDownloadStatus: dco_decode_i_32(arr[13]),
      coverFormat: dco_decode_String(arr[14]),
      coverWidth: dco_decode_u_32(arr[15]),
      coverHeight: dco_decode_u_32(arr[16]),
      downloadStatus: dco_decode_i_32(arr[17]),
      imageCount: dco_decode_i_32(arr[18]),
      imageCountDownload: dco_decode_i_32(arr[19]),
    );
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  PlatformInt64 dco_decode_i_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeI64(raw);
  }

  @protected
  Item dco_decode_item(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return Item(
      id: dco_decode_i_32(arr[0]),
      title: dco_decode_String(arr[1]),
    );
  }

  @protected
  List<String> dco_decode_list_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_String).toList();
  }

  @protected
  List<ComicCategory> dco_decode_list_comic_category(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_comic_category).toList();
  }

  @protected
  List<ComicChapter> dco_decode_list_comic_chapter(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_comic_chapter).toList();
  }

  @protected
  List<ComicChapterInfo> dco_decode_list_comic_chapter_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_comic_chapter_info).toList();
  }

  @protected
  List<ComicFilter> dco_decode_list_comic_filter(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_comic_filter).toList();
  }

  @protected
  List<ComicFilterItem> dco_decode_list_comic_filter_item(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_comic_filter_item).toList();
  }

  @protected
  List<ComicInFilter> dco_decode_list_comic_in_filter(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_comic_in_filter).toList();
  }

  @protected
  List<ComicInSearch> dco_decode_list_comic_in_search(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_comic_in_search).toList();
  }

  @protected
  List<ComicRankListItem> dco_decode_list_comic_rank_list_item(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_comic_rank_list_item).toList();
  }

  @protected
  List<ComicUpdateListItem> dco_decode_list_comic_update_list_item(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_comic_update_list_item)
        .toList();
  }

  @protected
  List<ComicViewLog> dco_decode_list_comic_view_log(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_comic_view_log).toList();
  }

  @protected
  List<Comment> dco_decode_list_comment(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_comment).toList();
  }

  @protected
  List<DayList> dco_decode_list_day_list(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_day_list).toList();
  }

  @protected
  List<DownloadComic> dco_decode_list_download_comic(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_download_comic).toList();
  }

  @protected
  List<Item> dco_decode_list_item(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_item).toList();
  }

  @protected
  List<MasterComment> dco_decode_list_master_comment(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_master_comment).toList();
  }

  @protected
  List<NewsCategory> dco_decode_list_news_category(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_news_category).toList();
  }

  @protected
  List<NewsListItem> dco_decode_list_news_list_item(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_news_list_item).toList();
  }

  @protected
  List<NovelCategory> dco_decode_list_novel_category(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_novel_category).toList();
  }

  @protected
  List<NovelChapter> dco_decode_list_novel_chapter(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_novel_chapter).toList();
  }

  @protected
  List<NovelInFilter> dco_decode_list_novel_in_filter(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_novel_in_filter).toList();
  }

  @protected
  List<NovelInSearch> dco_decode_list_novel_in_search(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_novel_in_search).toList();
  }

  @protected
  List<NovelViewLog> dco_decode_list_novel_view_log(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_novel_view_log).toList();
  }

  @protected
  List<NovelVolume> dco_decode_list_novel_volume(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_novel_volume).toList();
  }

  @protected
  List<NovelVolumeInfo> dco_decode_list_novel_volume_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_novel_volume_info).toList();
  }

  @protected
  List<int> dco_decode_list_prim_i_32_loose(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as List<int>;
  }

  @protected
  Int32List dco_decode_list_prim_i_32_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Int32List;
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  List<Subscribed> dco_decode_list_subscribed(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_subscribed).toList();
  }

  @protected
  List<Task> dco_decode_list_task(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_task).toList();
  }

  @protected
  List<TaskList> dco_decode_list_task_list(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_task_list).toList();
  }

  @protected
  LocalImage dco_decode_local_image(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return LocalImage(
      absPath: dco_decode_String(arr[0]),
      localPath: dco_decode_String(arr[1]),
      imageFormat: dco_decode_String(arr[2]),
      imageWidth: dco_decode_u_32(arr[3]),
      imageHeight: dco_decode_u_32(arr[4]),
    );
  }

  @protected
  LoginData dco_decode_login_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7)
      throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return LoginData(
      uid: dco_decode_String(arr[0]),
      nickname: dco_decode_String(arr[1]),
      dmzjToken: dco_decode_String(arr[2]),
      photo: dco_decode_String(arr[3]),
      bindPhone: dco_decode_String(arr[4]),
      email: dco_decode_String(arr[5]),
      passwd: dco_decode_String(arr[6]),
    );
  }

  @protected
  LoginInfo dco_decode_login_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return LoginInfo(
      status: dco_decode_i_32(arr[0]),
      message: dco_decode_String(arr[1]),
      data: dco_decode_opt_box_autoadd_login_data(arr[2]),
    );
  }

  @protected
  MasterComment dco_decode_master_comment(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 18)
      throw Exception('unexpected arr length: expect 18 but see ${arr.length}');
    return MasterComment(
      id: dco_decode_i_64(arr[0]),
      isPassed: dco_decode_i_64(arr[1]),
      topStatus: dco_decode_i_64(arr[2]),
      isGoods: dco_decode_i_64(arr[3]),
      uploadImages: dco_decode_String(arr[4]),
      objId: dco_decode_i_64(arr[5]),
      content: dco_decode_String(arr[6]),
      senderUid: dco_decode_i_64(arr[7]),
      likeAmount: dco_decode_i_64(arr[8]),
      createTime: dco_decode_i_64(arr[9]),
      toUid: dco_decode_i_64(arr[10]),
      toCommentId: dco_decode_i_64(arr[11]),
      originCommentId: dco_decode_i_64(arr[12]),
      replyAmount: dco_decode_i_64(arr[13]),
      cover: dco_decode_String(arr[14]),
      nickname: dco_decode_String(arr[15]),
      hotCommentAmount: dco_decode_i_64(arr[16]),
      sex: dco_decode_i_64(arr[17]),
    );
  }

  @protected
  NewsCategory dco_decode_news_category(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return NewsCategory(
      tagId: dco_decode_i_64(arr[0]),
      tagName: dco_decode_String(arr[1]),
    );
  }

  @protected
  NewsListItem dco_decode_news_list_item(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 19)
      throw Exception('unexpected arr length: expect 19 but see ${arr.length}');
    return NewsListItem(
      id: dco_decode_i_32(arr[0]),
      title: dco_decode_String(arr[1]),
      fromName: dco_decode_String(arr[2]),
      fromUrl: dco_decode_String(arr[3]),
      createTime: dco_decode_i_64(arr[4]),
      isForeign: dco_decode_i_32(arr[5]),
      foreignUrl: dco_decode_String(arr[6]),
      intro: dco_decode_String(arr[7]),
      authorId: dco_decode_i_32(arr[8]),
      status: dco_decode_i_32(arr[9]),
      rowPicUrl: dco_decode_String(arr[10]),
      colPicUrl: dco_decode_String(arr[11]),
      qChatShow: dco_decode_i_32(arr[12]),
      pageUrl: dco_decode_String(arr[13]),
      commentAmount: dco_decode_i_32(arr[14]),
      authorUid: dco_decode_i_32(arr[15]),
      cover: dco_decode_String(arr[16]),
      nickname: dco_decode_String(arr[17]),
      moodAmount: dco_decode_i_32(arr[18]),
    );
  }

  @protected
  NovelCategory dco_decode_novel_category(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return NovelCategory(
      tagId: dco_decode_i_64(arr[0]),
      title: dco_decode_String(arr[1]),
      cover: dco_decode_String(arr[2]),
    );
  }

  @protected
  NovelChapter dco_decode_novel_chapter(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return NovelChapter(
      chapterId: dco_decode_i_32(arr[0]),
      chapterName: dco_decode_String(arr[1]),
      chapterOrder: dco_decode_i_32(arr[2]),
    );
  }

  @protected
  NovelDetail dco_decode_novel_detail(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 18)
      throw Exception('unexpected arr length: expect 18 but see ${arr.length}');
    return NovelDetail(
      id: dco_decode_i_32(arr[0]),
      name: dco_decode_String(arr[1]),
      zone: dco_decode_String(arr[2]),
      status: dco_decode_String(arr[3]),
      lastUpdateVolumeName: dco_decode_String(arr[4]),
      lastUpdateChapterName: dco_decode_String(arr[5]),
      lastUpdateVolumeId: dco_decode_i_32(arr[6]),
      lastUpdateChapterId: dco_decode_i_32(arr[7]),
      lastUpdateTime: dco_decode_i_64(arr[8]),
      cover: dco_decode_String(arr[9]),
      hotHits: dco_decode_i_32(arr[10]),
      introduction: dco_decode_String(arr[11]),
      types: dco_decode_list_String(arr[12]),
      authors: dco_decode_String(arr[13]),
      firstLetter: dco_decode_String(arr[14]),
      subscribeNum: dco_decode_i_32(arr[15]),
      redisUpdateTime: dco_decode_i_64(arr[16]),
      volumes: dco_decode_list_novel_volume_info(arr[17]),
    );
  }

  @protected
  NovelInFilter dco_decode_novel_in_filter(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return NovelInFilter(
      cover: dco_decode_String(arr[0]),
      name: dco_decode_String(arr[1]),
      authors: dco_decode_String(arr[2]),
      id: dco_decode_i_64(arr[3]),
    );
  }

  @protected
  NovelInSearch dco_decode_novel_in_search(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 12)
      throw Exception('unexpected arr length: expect 12 but see ${arr.length}');
    return NovelInSearch(
      biz: dco_decode_String(arr[0]),
      addtime: dco_decode_i_64(arr[1]),
      authors: dco_decode_String(arr[2]),
      copyright: dco_decode_i_64(arr[3]),
      cover: dco_decode_String(arr[4]),
      hidden: dco_decode_i_64(arr[5]),
      hotHits: dco_decode_i_64(arr[6]),
      lastName: dco_decode_String(arr[7]),
      status: dco_decode_i_64(arr[8]),
      title: dco_decode_String(arr[9]),
      types: dco_decode_String(arr[10]),
      id: dco_decode_i_64(arr[11]),
    );
  }

  @protected
  NovelViewLog dco_decode_novel_view_log(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 25)
      throw Exception('unexpected arr length: expect 25 but see ${arr.length}');
    return NovelViewLog(
      novelId: dco_decode_i_32(arr[0]),
      novelTitle: dco_decode_String(arr[1]),
      novelZone: dco_decode_String(arr[2]),
      novelStatus: dco_decode_String(arr[3]),
      novelLastUpdateVolumeName: dco_decode_String(arr[4]),
      novelLastUpdateChapterName: dco_decode_String(arr[5]),
      novelLastUpdateVolumeId: dco_decode_i_32(arr[6]),
      novelLastUpdateChapterId: dco_decode_i_32(arr[7]),
      novelLastUpdateTime: dco_decode_i_64(arr[8]),
      novelCover: dco_decode_String(arr[9]),
      novelHotHits: dco_decode_i_32(arr[10]),
      novelIntroduction: dco_decode_String(arr[11]),
      novelTypes: dco_decode_String(arr[12]),
      novelAuthors: dco_decode_String(arr[13]),
      novelFirstLetter: dco_decode_String(arr[14]),
      novelSubscribeNum: dco_decode_i_32(arr[15]),
      novelRedisUpdateTime: dco_decode_i_64(arr[16]),
      volumeId: dco_decode_i_32(arr[17]),
      volumeTitle: dco_decode_String(arr[18]),
      volumeOrder: dco_decode_i_32(arr[19]),
      chapterId: dco_decode_i_32(arr[20]),
      chapterTitle: dco_decode_String(arr[21]),
      chapterOrder: dco_decode_i_32(arr[22]),
      progress: dco_decode_i_64(arr[23]),
      viewTime: dco_decode_i_64(arr[24]),
    );
  }

  @protected
  NovelVolume dco_decode_novel_volume(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return NovelVolume(
      id: dco_decode_i_32(arr[0]),
      title: dco_decode_String(arr[1]),
      rank: dco_decode_i_32(arr[2]),
      chapters: dco_decode_list_novel_chapter(arr[3]),
    );
  }

  @protected
  NovelVolumeInfo dco_decode_novel_volume_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return NovelVolumeInfo(
      id: dco_decode_i_32(arr[0]),
      novelId: dco_decode_i_32(arr[1]),
      title: dco_decode_String(arr[2]),
      rank: dco_decode_i_32(arr[3]),
      addTime: dco_decode_i_64(arr[4]),
      chaptersCount: dco_decode_i_32(arr[5]),
    );
  }

  @protected
  ComicViewLog? dco_decode_opt_box_autoadd_comic_view_log(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_comic_view_log(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_i_32(raw);
  }

  @protected
  LoginData? dco_decode_opt_box_autoadd_login_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_login_data(raw);
  }

  @protected
  NovelViewLog? dco_decode_opt_box_autoadd_novel_view_log(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_novel_view_log(raw);
  }

  @protected
  Subscribed dco_decode_subscribed(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8)
      throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return Subscribed(
      name: dco_decode_String(arr[0]),
      subUpdate: dco_decode_String(arr[1]),
      subImg: dco_decode_String(arr[2]),
      subUptime: dco_decode_i_64(arr[3]),
      subFirstLetter: dco_decode_String(arr[4]),
      subReaded: dco_decode_i_64(arr[5]),
      id: dco_decode_i_64(arr[6]),
      status: dco_decode_String(arr[7]),
    );
  }

  @protected
  SummationsTask dco_decode_summations_task(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return SummationsTask(
      signCount: dco_decode_i_64(arr[0]),
      maxSignCount: dco_decode_i_64(arr[1]),
      taskList: dco_decode_list_task_list(arr[2]),
    );
  }

  @protected
  Task dco_decode_task(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 12)
      throw Exception('unexpected arr length: expect 12 but see ${arr.length}');
    return Task(
      id: dco_decode_i_64(arr[0]),
      title: dco_decode_String(arr[1]),
      con: dco_decode_String(arr[2]),
      icon: dco_decode_String(arr[3]),
      times: dco_decode_i_64(arr[4]),
      nums: dco_decode_i_64(arr[5]),
      source: dco_decode_i_64(arr[6]),
      typeId: dco_decode_i_64(arr[7]),
      url: dco_decode_String(arr[8]),
      btn: dco_decode_String(arr[9]),
      status: dco_decode_i_64(arr[10]),
      progress: dco_decode_i_64(arr[11]),
    );
  }

  @protected
  TaskIndex dco_decode_task_index(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8)
      throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return TaskIndex(
      newPersonTask: dco_decode_list_task(arr[0]),
      dayTask: dco_decode_list_task(arr[1]),
      weekTask: dco_decode_list_task(arr[2]),
      summationsTask: dco_decode_summations_task(arr[3]),
      daySignTask: dco_decode_day_sign_task(arr[4]),
      creditsNums: dco_decode_i_64(arr[5]),
      silverNums: dco_decode_i_64(arr[6]),
      starsNums: dco_decode_i_64(arr[7]),
    );
  }

  @protected
  TaskList dco_decode_task_list(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 13)
      throw Exception('unexpected arr length: expect 13 but see ${arr.length}');
    return TaskList(
      id: dco_decode_i_64(arr[0]),
      title: dco_decode_String(arr[1]),
      con: dco_decode_String(arr[2]),
      icon: dco_decode_String(arr[3]),
      times: dco_decode_i_64(arr[4]),
      nums: dco_decode_i_64(arr[5]),
      source: dco_decode_i_64(arr[6]),
      typeId: dco_decode_i_64(arr[7]),
      url: dco_decode_String(arr[8]),
      btn: dco_decode_String(arr[9]),
      status: dco_decode_i_64(arr[10]),
      progress: dco_decode_i_64(arr[11]),
      iconChecked: dco_decode_String(arr[12]),
    );
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_String(deserializer);
    return AnyhowException(inner);
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  ComicDetail sse_decode_box_autoadd_comic_detail(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_comic_detail(deserializer));
  }

  @protected
  ComicViewLog sse_decode_box_autoadd_comic_view_log(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_comic_view_log(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_i_32(deserializer));
  }

  @protected
  LoginData sse_decode_box_autoadd_login_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_login_data(deserializer));
  }

  @protected
  NovelViewLog sse_decode_box_autoadd_novel_view_log(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_novel_view_log(deserializer));
  }

  @protected
  ComicCategory sse_decode_comic_category(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_tagId = sse_decode_i_32(deserializer);
    var var_title = sse_decode_String(deserializer);
    var var_cover = sse_decode_String(deserializer);
    return ComicCategory(tagId: var_tagId, title: var_title, cover: var_cover);
  }

  @protected
  ComicChapter sse_decode_comic_chapter(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_title = sse_decode_String(deserializer);
    var var_data = sse_decode_list_comic_chapter_info(deserializer);
    return ComicChapter(title: var_title, data: var_data);
  }

  @protected
  ComicChapterDetail sse_decode_comic_chapter_detail(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_chapterId = sse_decode_i_64(deserializer);
    var var_comicId = sse_decode_i_64(deserializer);
    var var_title = sse_decode_String(deserializer);
    var var_chapterOrder = sse_decode_i_32(deserializer);
    var var_direction = sse_decode_i_32(deserializer);
    var var_pageUrl = sse_decode_list_String(deserializer);
    var var_picnum = sse_decode_i_32(deserializer);
    var var_pageUrlHd = sse_decode_list_String(deserializer);
    var var_commentCount = sse_decode_i_32(deserializer);
    return ComicChapterDetail(
        chapterId: var_chapterId,
        comicId: var_comicId,
        title: var_title,
        chapterOrder: var_chapterOrder,
        direction: var_direction,
        pageUrl: var_pageUrl,
        picnum: var_picnum,
        pageUrlHd: var_pageUrlHd,
        commentCount: var_commentCount);
  }

  @protected
  ComicChapterInfo sse_decode_comic_chapter_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_chapterId = sse_decode_i_32(deserializer);
    var var_chapterTitle = sse_decode_String(deserializer);
    var var_updateTime = sse_decode_i_64(deserializer);
    var var_fileSize = sse_decode_i_32(deserializer);
    var var_chapterOrder = sse_decode_i_32(deserializer);
    return ComicChapterInfo(
        chapterId: var_chapterId,
        chapterTitle: var_chapterTitle,
        updateTime: var_updateTime,
        fileSize: var_fileSize,
        chapterOrder: var_chapterOrder);
  }

  @protected
  ComicDetail sse_decode_comic_detail(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_i_32(deserializer);
    var var_title = sse_decode_String(deserializer);
    var var_direction = sse_decode_i_32(deserializer);
    var var_isLong = sse_decode_i_32(deserializer);
    var var_isAnimeHome = sse_decode_i_32(deserializer);
    var var_cover = sse_decode_String(deserializer);
    var var_description = sse_decode_String(deserializer);
    var var_lastUpdateTime = sse_decode_i_64(deserializer);
    var var_lastUpdateChapterName = sse_decode_String(deserializer);
    var var_copyright = sse_decode_i_32(deserializer);
    var var_firstLetter = sse_decode_String(deserializer);
    var var_comicPy = sse_decode_String(deserializer);
    var var_hidden = sse_decode_i_32(deserializer);
    var var_hotNum = sse_decode_i_32(deserializer);
    var var_hitNum = sse_decode_i_32(deserializer);
    var var_uid = sse_decode_i_32(deserializer);
    var var_isLock = sse_decode_i_32(deserializer);
    var var_lastUpdateChapterId = sse_decode_i_32(deserializer);
    var var_types = sse_decode_list_item(deserializer);
    var var_status = sse_decode_list_item(deserializer);
    var var_authors = sse_decode_list_item(deserializer);
    var var_subscribeNum = sse_decode_i_32(deserializer);
    var var_chapters = sse_decode_list_comic_chapter(deserializer);
    var var_isNeedLogin = sse_decode_i_32(deserializer);
    var var_isHideChapter = sse_decode_i_32(deserializer);
    return ComicDetail(
        id: var_id,
        title: var_title,
        direction: var_direction,
        isLong: var_isLong,
        isAnimeHome: var_isAnimeHome,
        cover: var_cover,
        description: var_description,
        lastUpdateTime: var_lastUpdateTime,
        lastUpdateChapterName: var_lastUpdateChapterName,
        copyright: var_copyright,
        firstLetter: var_firstLetter,
        comicPy: var_comicPy,
        hidden: var_hidden,
        hotNum: var_hotNum,
        hitNum: var_hitNum,
        uid: var_uid,
        isLock: var_isLock,
        lastUpdateChapterId: var_lastUpdateChapterId,
        types: var_types,
        status: var_status,
        authors: var_authors,
        subscribeNum: var_subscribeNum,
        chapters: var_chapters,
        isNeedLogin: var_isNeedLogin,
        isHideChapter: var_isHideChapter);
  }

  @protected
  ComicFilter sse_decode_comic_filter(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_title = sse_decode_String(deserializer);
    var var_items = sse_decode_list_comic_filter_item(deserializer);
    return ComicFilter(title: var_title, items: var_items);
  }

  @protected
  ComicFilterItem sse_decode_comic_filter_item(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_tagId = sse_decode_i_64(deserializer);
    var var_tagName = sse_decode_String(deserializer);
    return ComicFilterItem(tagId: var_tagId, tagName: var_tagName);
  }

  @protected
  ComicInFilter sse_decode_comic_in_filter(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_i_64(deserializer);
    var var_title = sse_decode_String(deserializer);
    var var_authors = sse_decode_String(deserializer);
    var var_status = sse_decode_String(deserializer);
    var var_cover = sse_decode_String(deserializer);
    var var_types = sse_decode_String(deserializer);
    var var_lastUpdateTime = sse_decode_i_64(deserializer);
    var var_num = sse_decode_i_64(deserializer);
    return ComicInFilter(
        id: var_id,
        title: var_title,
        authors: var_authors,
        status: var_status,
        cover: var_cover,
        types: var_types,
        lastUpdateTime: var_lastUpdateTime,
        num: var_num);
  }

  @protected
  ComicInSearch sse_decode_comic_in_search(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_biz = sse_decode_String(deserializer);
    var var_addtime = sse_decode_i_64(deserializer);
    var var_authors = sse_decode_String(deserializer);
    var var_copyright = sse_decode_i_64(deserializer);
    var var_cover = sse_decode_String(deserializer);
    var var_hidden = sse_decode_i_64(deserializer);
    var var_hotHits = sse_decode_i_64(deserializer);
    var var_lastName = sse_decode_String(deserializer);
    var var_status = sse_decode_i_64(deserializer);
    var var_title = sse_decode_String(deserializer);
    var var_types = sse_decode_String(deserializer);
    var var_id = sse_decode_i_64(deserializer);
    return ComicInSearch(
        biz: var_biz,
        addtime: var_addtime,
        authors: var_authors,
        copyright: var_copyright,
        cover: var_cover,
        hidden: var_hidden,
        hotHits: var_hotHits,
        lastName: var_lastName,
        status: var_status,
        title: var_title,
        types: var_types,
        id: var_id);
  }

  @protected
  ComicRankListItem sse_decode_comic_rank_list_item(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_i_32(deserializer);
    var var_title = sse_decode_String(deserializer);
    var var_authors = sse_decode_String(deserializer);
    var var_status = sse_decode_String(deserializer);
    var var_cover = sse_decode_String(deserializer);
    var var_types = sse_decode_String(deserializer);
    var var_lastUpdateTime = sse_decode_i_64(deserializer);
    var var_lastUpdateChapterName = sse_decode_String(deserializer);
    var var_comicPy = sse_decode_String(deserializer);
    var var_num = sse_decode_i_32(deserializer);
    var var_tagId = sse_decode_i_32(deserializer);
    var var_chapterName = sse_decode_String(deserializer);
    var var_chapterId = sse_decode_i_32(deserializer);
    return ComicRankListItem(
        id: var_id,
        title: var_title,
        authors: var_authors,
        status: var_status,
        cover: var_cover,
        types: var_types,
        lastUpdateTime: var_lastUpdateTime,
        lastUpdateChapterName: var_lastUpdateChapterName,
        comicPy: var_comicPy,
        num: var_num,
        tagId: var_tagId,
        chapterName: var_chapterName,
        chapterId: var_chapterId);
  }

  @protected
  ComicUpdateListItem sse_decode_comic_update_list_item(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_i_32(deserializer);
    var var_title = sse_decode_String(deserializer);
    var var_isLong = sse_decode_bool(deserializer);
    var var_authors = sse_decode_String(deserializer);
    var var_types = sse_decode_String(deserializer);
    var var_cover = sse_decode_String(deserializer);
    var var_status = sse_decode_String(deserializer);
    var var_lastUpdateChapterName = sse_decode_String(deserializer);
    var var_lastUpdateChapterId = sse_decode_i_32(deserializer);
    var var_lastUpdateTime = sse_decode_i_64(deserializer);
    return ComicUpdateListItem(
        id: var_id,
        title: var_title,
        isLong: var_isLong,
        authors: var_authors,
        types: var_types,
        cover: var_cover,
        status: var_status,
        lastUpdateChapterName: var_lastUpdateChapterName,
        lastUpdateChapterId: var_lastUpdateChapterId,
        lastUpdateTime: var_lastUpdateTime);
  }

  @protected
  ComicViewLog sse_decode_comic_view_log(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_comicId = sse_decode_i_32(deserializer);
    var var_comicTitle = sse_decode_String(deserializer);
    var var_comicAuthors = sse_decode_String(deserializer);
    var var_comicStatus = sse_decode_String(deserializer);
    var var_comicCover = sse_decode_String(deserializer);
    var var_comicTypes = sse_decode_String(deserializer);
    var var_comicLastUpdateTime = sse_decode_i_64(deserializer);
    var var_comicLastUpdateChapterName = sse_decode_String(deserializer);
    var var_chapterId = sse_decode_i_32(deserializer);
    var var_chapterTitle = sse_decode_String(deserializer);
    var var_chapterOrder = sse_decode_i_32(deserializer);
    var var_pageRank = sse_decode_i_32(deserializer);
    var var_viewTime = sse_decode_i_64(deserializer);
    return ComicViewLog(
        comicId: var_comicId,
        comicTitle: var_comicTitle,
        comicAuthors: var_comicAuthors,
        comicStatus: var_comicStatus,
        comicCover: var_comicCover,
        comicTypes: var_comicTypes,
        comicLastUpdateTime: var_comicLastUpdateTime,
        comicLastUpdateChapterName: var_comicLastUpdateChapterName,
        chapterId: var_chapterId,
        chapterTitle: var_chapterTitle,
        chapterOrder: var_chapterOrder,
        pageRank: var_pageRank,
        viewTime: var_viewTime);
  }

  @protected
  Comment sse_decode_comment(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_i_64(deserializer);
    var var_isPassed = sse_decode_i_64(deserializer);
    var var_topStatus = sse_decode_i_64(deserializer);
    var var_isGoods = sse_decode_i_64(deserializer);
    var var_uploadImages = sse_decode_String(deserializer);
    var var_objId = sse_decode_i_64(deserializer);
    var var_content = sse_decode_String(deserializer);
    var var_senderUid = sse_decode_i_64(deserializer);
    var var_likeAmount = sse_decode_i_64(deserializer);
    var var_createTime = sse_decode_i_64(deserializer);
    var var_toUid = sse_decode_i_64(deserializer);
    var var_toCommentId = sse_decode_i_64(deserializer);
    var var_originCommentId = sse_decode_i_64(deserializer);
    var var_replyAmount = sse_decode_i_64(deserializer);
    var var_hotCommentAmount = sse_decode_i_64(deserializer);
    var var_cover = sse_decode_String(deserializer);
    var var_nickname = sse_decode_String(deserializer);
    var var_avatarUrl = sse_decode_String(deserializer);
    var var_sex = sse_decode_i_64(deserializer);
    var var_masterCommentNum = sse_decode_i_64(deserializer);
    var var_masterComment = sse_decode_list_master_comment(deserializer);
    return Comment(
        id: var_id,
        isPassed: var_isPassed,
        topStatus: var_topStatus,
        isGoods: var_isGoods,
        uploadImages: var_uploadImages,
        objId: var_objId,
        content: var_content,
        senderUid: var_senderUid,
        likeAmount: var_likeAmount,
        createTime: var_createTime,
        toUid: var_toUid,
        toCommentId: var_toCommentId,
        originCommentId: var_originCommentId,
        replyAmount: var_replyAmount,
        hotCommentAmount: var_hotCommentAmount,
        cover: var_cover,
        nickname: var_nickname,
        avatarUrl: var_avatarUrl,
        sex: var_sex,
        masterCommentNum: var_masterCommentNum,
        masterComment: var_masterComment);
  }

  @protected
  DayList sse_decode_day_list(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_i_64(deserializer);
    var var_title = sse_decode_String(deserializer);
    var var_icon = sse_decode_String(deserializer);
    var var_iconChecked = sse_decode_String(deserializer);
    var var_typeId = sse_decode_i_64(deserializer);
    var var_times = sse_decode_i_64(deserializer);
    var var_nums = sse_decode_i_64(deserializer);
    var var_creditsNums = sse_decode_i_64(deserializer);
    return DayList(
        id: var_id,
        title: var_title,
        icon: var_icon,
        iconChecked: var_iconChecked,
        typeId: var_typeId,
        times: var_times,
        nums: var_nums,
        creditsNums: var_creditsNums);
  }

  @protected
  DaySignTask sse_decode_day_sign_task(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_currentDay = sse_decode_i_64(deserializer);
    var var_status = sse_decode_i_64(deserializer);
    var var_doubleStatus = sse_decode_i_64(deserializer);
    var var_dayList = sse_decode_list_day_list(deserializer);
    return DaySignTask(
        currentDay: var_currentDay,
        status: var_status,
        doubleStatus: var_doubleStatus,
        dayList: var_dayList);
  }

  @protected
  DownloadComic sse_decode_download_comic(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_i_32(deserializer);
    var var_title = sse_decode_String(deserializer);
    var var_authors = sse_decode_String(deserializer);
    var var_types = sse_decode_String(deserializer);
    var var_status = sse_decode_String(deserializer);
    var var_direction = sse_decode_i_32(deserializer);
    var var_isLong = sse_decode_i_32(deserializer);
    var var_isAnimeHome = sse_decode_i_32(deserializer);
    var var_cover = sse_decode_String(deserializer);
    var var_description = sse_decode_String(deserializer);
    var var_copyright = sse_decode_i_32(deserializer);
    var var_firstLetter = sse_decode_String(deserializer);
    var var_comicPy = sse_decode_String(deserializer);
    var var_coverDownloadStatus = sse_decode_i_32(deserializer);
    var var_coverFormat = sse_decode_String(deserializer);
    var var_coverWidth = sse_decode_u_32(deserializer);
    var var_coverHeight = sse_decode_u_32(deserializer);
    var var_downloadStatus = sse_decode_i_32(deserializer);
    var var_imageCount = sse_decode_i_32(deserializer);
    var var_imageCountDownload = sse_decode_i_32(deserializer);
    return DownloadComic(
        id: var_id,
        title: var_title,
        authors: var_authors,
        types: var_types,
        status: var_status,
        direction: var_direction,
        isLong: var_isLong,
        isAnimeHome: var_isAnimeHome,
        cover: var_cover,
        description: var_description,
        copyright: var_copyright,
        firstLetter: var_firstLetter,
        comicPy: var_comicPy,
        coverDownloadStatus: var_coverDownloadStatus,
        coverFormat: var_coverFormat,
        coverWidth: var_coverWidth,
        coverHeight: var_coverHeight,
        downloadStatus: var_downloadStatus,
        imageCount: var_imageCount,
        imageCountDownload: var_imageCountDownload);
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  PlatformInt64 sse_decode_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getPlatformInt64();
  }

  @protected
  Item sse_decode_item(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_i_32(deserializer);
    var var_title = sse_decode_String(deserializer);
    return Item(id: var_id, title: var_title);
  }

  @protected
  List<String> sse_decode_list_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <String>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_String(deserializer));
    }
    return ans_;
  }

  @protected
  List<ComicCategory> sse_decode_list_comic_category(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ComicCategory>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_comic_category(deserializer));
    }
    return ans_;
  }

  @protected
  List<ComicChapter> sse_decode_list_comic_chapter(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ComicChapter>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_comic_chapter(deserializer));
    }
    return ans_;
  }

  @protected
  List<ComicChapterInfo> sse_decode_list_comic_chapter_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ComicChapterInfo>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_comic_chapter_info(deserializer));
    }
    return ans_;
  }

  @protected
  List<ComicFilter> sse_decode_list_comic_filter(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ComicFilter>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_comic_filter(deserializer));
    }
    return ans_;
  }

  @protected
  List<ComicFilterItem> sse_decode_list_comic_filter_item(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ComicFilterItem>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_comic_filter_item(deserializer));
    }
    return ans_;
  }

  @protected
  List<ComicInFilter> sse_decode_list_comic_in_filter(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ComicInFilter>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_comic_in_filter(deserializer));
    }
    return ans_;
  }

  @protected
  List<ComicInSearch> sse_decode_list_comic_in_search(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ComicInSearch>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_comic_in_search(deserializer));
    }
    return ans_;
  }

  @protected
  List<ComicRankListItem> sse_decode_list_comic_rank_list_item(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ComicRankListItem>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_comic_rank_list_item(deserializer));
    }
    return ans_;
  }

  @protected
  List<ComicUpdateListItem> sse_decode_list_comic_update_list_item(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ComicUpdateListItem>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_comic_update_list_item(deserializer));
    }
    return ans_;
  }

  @protected
  List<ComicViewLog> sse_decode_list_comic_view_log(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ComicViewLog>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_comic_view_log(deserializer));
    }
    return ans_;
  }

  @protected
  List<Comment> sse_decode_list_comment(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Comment>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_comment(deserializer));
    }
    return ans_;
  }

  @protected
  List<DayList> sse_decode_list_day_list(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <DayList>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_day_list(deserializer));
    }
    return ans_;
  }

  @protected
  List<DownloadComic> sse_decode_list_download_comic(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <DownloadComic>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_download_comic(deserializer));
    }
    return ans_;
  }

  @protected
  List<Item> sse_decode_list_item(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Item>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_item(deserializer));
    }
    return ans_;
  }

  @protected
  List<MasterComment> sse_decode_list_master_comment(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <MasterComment>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_master_comment(deserializer));
    }
    return ans_;
  }

  @protected
  List<NewsCategory> sse_decode_list_news_category(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <NewsCategory>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_news_category(deserializer));
    }
    return ans_;
  }

  @protected
  List<NewsListItem> sse_decode_list_news_list_item(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <NewsListItem>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_news_list_item(deserializer));
    }
    return ans_;
  }

  @protected
  List<NovelCategory> sse_decode_list_novel_category(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <NovelCategory>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_novel_category(deserializer));
    }
    return ans_;
  }

  @protected
  List<NovelChapter> sse_decode_list_novel_chapter(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <NovelChapter>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_novel_chapter(deserializer));
    }
    return ans_;
  }

  @protected
  List<NovelInFilter> sse_decode_list_novel_in_filter(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <NovelInFilter>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_novel_in_filter(deserializer));
    }
    return ans_;
  }

  @protected
  List<NovelInSearch> sse_decode_list_novel_in_search(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <NovelInSearch>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_novel_in_search(deserializer));
    }
    return ans_;
  }

  @protected
  List<NovelViewLog> sse_decode_list_novel_view_log(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <NovelViewLog>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_novel_view_log(deserializer));
    }
    return ans_;
  }

  @protected
  List<NovelVolume> sse_decode_list_novel_volume(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <NovelVolume>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_novel_volume(deserializer));
    }
    return ans_;
  }

  @protected
  List<NovelVolumeInfo> sse_decode_list_novel_volume_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <NovelVolumeInfo>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_novel_volume_info(deserializer));
    }
    return ans_;
  }

  @protected
  List<int> sse_decode_list_prim_i_32_loose(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getInt32List(len_);
  }

  @protected
  Int32List sse_decode_list_prim_i_32_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getInt32List(len_);
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<Subscribed> sse_decode_list_subscribed(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Subscribed>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_subscribed(deserializer));
    }
    return ans_;
  }

  @protected
  List<Task> sse_decode_list_task(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Task>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_task(deserializer));
    }
    return ans_;
  }

  @protected
  List<TaskList> sse_decode_list_task_list(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <TaskList>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_task_list(deserializer));
    }
    return ans_;
  }

  @protected
  LocalImage sse_decode_local_image(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_absPath = sse_decode_String(deserializer);
    var var_localPath = sse_decode_String(deserializer);
    var var_imageFormat = sse_decode_String(deserializer);
    var var_imageWidth = sse_decode_u_32(deserializer);
    var var_imageHeight = sse_decode_u_32(deserializer);
    return LocalImage(
        absPath: var_absPath,
        localPath: var_localPath,
        imageFormat: var_imageFormat,
        imageWidth: var_imageWidth,
        imageHeight: var_imageHeight);
  }

  @protected
  LoginData sse_decode_login_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_uid = sse_decode_String(deserializer);
    var var_nickname = sse_decode_String(deserializer);
    var var_dmzjToken = sse_decode_String(deserializer);
    var var_photo = sse_decode_String(deserializer);
    var var_bindPhone = sse_decode_String(deserializer);
    var var_email = sse_decode_String(deserializer);
    var var_passwd = sse_decode_String(deserializer);
    return LoginData(
        uid: var_uid,
        nickname: var_nickname,
        dmzjToken: var_dmzjToken,
        photo: var_photo,
        bindPhone: var_bindPhone,
        email: var_email,
        passwd: var_passwd);
  }

  @protected
  LoginInfo sse_decode_login_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_status = sse_decode_i_32(deserializer);
    var var_message = sse_decode_String(deserializer);
    var var_data = sse_decode_opt_box_autoadd_login_data(deserializer);
    return LoginInfo(status: var_status, message: var_message, data: var_data);
  }

  @protected
  MasterComment sse_decode_master_comment(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_i_64(deserializer);
    var var_isPassed = sse_decode_i_64(deserializer);
    var var_topStatus = sse_decode_i_64(deserializer);
    var var_isGoods = sse_decode_i_64(deserializer);
    var var_uploadImages = sse_decode_String(deserializer);
    var var_objId = sse_decode_i_64(deserializer);
    var var_content = sse_decode_String(deserializer);
    var var_senderUid = sse_decode_i_64(deserializer);
    var var_likeAmount = sse_decode_i_64(deserializer);
    var var_createTime = sse_decode_i_64(deserializer);
    var var_toUid = sse_decode_i_64(deserializer);
    var var_toCommentId = sse_decode_i_64(deserializer);
    var var_originCommentId = sse_decode_i_64(deserializer);
    var var_replyAmount = sse_decode_i_64(deserializer);
    var var_cover = sse_decode_String(deserializer);
    var var_nickname = sse_decode_String(deserializer);
    var var_hotCommentAmount = sse_decode_i_64(deserializer);
    var var_sex = sse_decode_i_64(deserializer);
    return MasterComment(
        id: var_id,
        isPassed: var_isPassed,
        topStatus: var_topStatus,
        isGoods: var_isGoods,
        uploadImages: var_uploadImages,
        objId: var_objId,
        content: var_content,
        senderUid: var_senderUid,
        likeAmount: var_likeAmount,
        createTime: var_createTime,
        toUid: var_toUid,
        toCommentId: var_toCommentId,
        originCommentId: var_originCommentId,
        replyAmount: var_replyAmount,
        cover: var_cover,
        nickname: var_nickname,
        hotCommentAmount: var_hotCommentAmount,
        sex: var_sex);
  }

  @protected
  NewsCategory sse_decode_news_category(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_tagId = sse_decode_i_64(deserializer);
    var var_tagName = sse_decode_String(deserializer);
    return NewsCategory(tagId: var_tagId, tagName: var_tagName);
  }

  @protected
  NewsListItem sse_decode_news_list_item(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_i_32(deserializer);
    var var_title = sse_decode_String(deserializer);
    var var_fromName = sse_decode_String(deserializer);
    var var_fromUrl = sse_decode_String(deserializer);
    var var_createTime = sse_decode_i_64(deserializer);
    var var_isForeign = sse_decode_i_32(deserializer);
    var var_foreignUrl = sse_decode_String(deserializer);
    var var_intro = sse_decode_String(deserializer);
    var var_authorId = sse_decode_i_32(deserializer);
    var var_status = sse_decode_i_32(deserializer);
    var var_rowPicUrl = sse_decode_String(deserializer);
    var var_colPicUrl = sse_decode_String(deserializer);
    var var_qChatShow = sse_decode_i_32(deserializer);
    var var_pageUrl = sse_decode_String(deserializer);
    var var_commentAmount = sse_decode_i_32(deserializer);
    var var_authorUid = sse_decode_i_32(deserializer);
    var var_cover = sse_decode_String(deserializer);
    var var_nickname = sse_decode_String(deserializer);
    var var_moodAmount = sse_decode_i_32(deserializer);
    return NewsListItem(
        id: var_id,
        title: var_title,
        fromName: var_fromName,
        fromUrl: var_fromUrl,
        createTime: var_createTime,
        isForeign: var_isForeign,
        foreignUrl: var_foreignUrl,
        intro: var_intro,
        authorId: var_authorId,
        status: var_status,
        rowPicUrl: var_rowPicUrl,
        colPicUrl: var_colPicUrl,
        qChatShow: var_qChatShow,
        pageUrl: var_pageUrl,
        commentAmount: var_commentAmount,
        authorUid: var_authorUid,
        cover: var_cover,
        nickname: var_nickname,
        moodAmount: var_moodAmount);
  }

  @protected
  NovelCategory sse_decode_novel_category(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_tagId = sse_decode_i_64(deserializer);
    var var_title = sse_decode_String(deserializer);
    var var_cover = sse_decode_String(deserializer);
    return NovelCategory(tagId: var_tagId, title: var_title, cover: var_cover);
  }

  @protected
  NovelChapter sse_decode_novel_chapter(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_chapterId = sse_decode_i_32(deserializer);
    var var_chapterName = sse_decode_String(deserializer);
    var var_chapterOrder = sse_decode_i_32(deserializer);
    return NovelChapter(
        chapterId: var_chapterId,
        chapterName: var_chapterName,
        chapterOrder: var_chapterOrder);
  }

  @protected
  NovelDetail sse_decode_novel_detail(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_i_32(deserializer);
    var var_name = sse_decode_String(deserializer);
    var var_zone = sse_decode_String(deserializer);
    var var_status = sse_decode_String(deserializer);
    var var_lastUpdateVolumeName = sse_decode_String(deserializer);
    var var_lastUpdateChapterName = sse_decode_String(deserializer);
    var var_lastUpdateVolumeId = sse_decode_i_32(deserializer);
    var var_lastUpdateChapterId = sse_decode_i_32(deserializer);
    var var_lastUpdateTime = sse_decode_i_64(deserializer);
    var var_cover = sse_decode_String(deserializer);
    var var_hotHits = sse_decode_i_32(deserializer);
    var var_introduction = sse_decode_String(deserializer);
    var var_types = sse_decode_list_String(deserializer);
    var var_authors = sse_decode_String(deserializer);
    var var_firstLetter = sse_decode_String(deserializer);
    var var_subscribeNum = sse_decode_i_32(deserializer);
    var var_redisUpdateTime = sse_decode_i_64(deserializer);
    var var_volumes = sse_decode_list_novel_volume_info(deserializer);
    return NovelDetail(
        id: var_id,
        name: var_name,
        zone: var_zone,
        status: var_status,
        lastUpdateVolumeName: var_lastUpdateVolumeName,
        lastUpdateChapterName: var_lastUpdateChapterName,
        lastUpdateVolumeId: var_lastUpdateVolumeId,
        lastUpdateChapterId: var_lastUpdateChapterId,
        lastUpdateTime: var_lastUpdateTime,
        cover: var_cover,
        hotHits: var_hotHits,
        introduction: var_introduction,
        types: var_types,
        authors: var_authors,
        firstLetter: var_firstLetter,
        subscribeNum: var_subscribeNum,
        redisUpdateTime: var_redisUpdateTime,
        volumes: var_volumes);
  }

  @protected
  NovelInFilter sse_decode_novel_in_filter(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_cover = sse_decode_String(deserializer);
    var var_name = sse_decode_String(deserializer);
    var var_authors = sse_decode_String(deserializer);
    var var_id = sse_decode_i_64(deserializer);
    return NovelInFilter(
        cover: var_cover, name: var_name, authors: var_authors, id: var_id);
  }

  @protected
  NovelInSearch sse_decode_novel_in_search(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_biz = sse_decode_String(deserializer);
    var var_addtime = sse_decode_i_64(deserializer);
    var var_authors = sse_decode_String(deserializer);
    var var_copyright = sse_decode_i_64(deserializer);
    var var_cover = sse_decode_String(deserializer);
    var var_hidden = sse_decode_i_64(deserializer);
    var var_hotHits = sse_decode_i_64(deserializer);
    var var_lastName = sse_decode_String(deserializer);
    var var_status = sse_decode_i_64(deserializer);
    var var_title = sse_decode_String(deserializer);
    var var_types = sse_decode_String(deserializer);
    var var_id = sse_decode_i_64(deserializer);
    return NovelInSearch(
        biz: var_biz,
        addtime: var_addtime,
        authors: var_authors,
        copyright: var_copyright,
        cover: var_cover,
        hidden: var_hidden,
        hotHits: var_hotHits,
        lastName: var_lastName,
        status: var_status,
        title: var_title,
        types: var_types,
        id: var_id);
  }

  @protected
  NovelViewLog sse_decode_novel_view_log(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_novelId = sse_decode_i_32(deserializer);
    var var_novelTitle = sse_decode_String(deserializer);
    var var_novelZone = sse_decode_String(deserializer);
    var var_novelStatus = sse_decode_String(deserializer);
    var var_novelLastUpdateVolumeName = sse_decode_String(deserializer);
    var var_novelLastUpdateChapterName = sse_decode_String(deserializer);
    var var_novelLastUpdateVolumeId = sse_decode_i_32(deserializer);
    var var_novelLastUpdateChapterId = sse_decode_i_32(deserializer);
    var var_novelLastUpdateTime = sse_decode_i_64(deserializer);
    var var_novelCover = sse_decode_String(deserializer);
    var var_novelHotHits = sse_decode_i_32(deserializer);
    var var_novelIntroduction = sse_decode_String(deserializer);
    var var_novelTypes = sse_decode_String(deserializer);
    var var_novelAuthors = sse_decode_String(deserializer);
    var var_novelFirstLetter = sse_decode_String(deserializer);
    var var_novelSubscribeNum = sse_decode_i_32(deserializer);
    var var_novelRedisUpdateTime = sse_decode_i_64(deserializer);
    var var_volumeId = sse_decode_i_32(deserializer);
    var var_volumeTitle = sse_decode_String(deserializer);
    var var_volumeOrder = sse_decode_i_32(deserializer);
    var var_chapterId = sse_decode_i_32(deserializer);
    var var_chapterTitle = sse_decode_String(deserializer);
    var var_chapterOrder = sse_decode_i_32(deserializer);
    var var_progress = sse_decode_i_64(deserializer);
    var var_viewTime = sse_decode_i_64(deserializer);
    return NovelViewLog(
        novelId: var_novelId,
        novelTitle: var_novelTitle,
        novelZone: var_novelZone,
        novelStatus: var_novelStatus,
        novelLastUpdateVolumeName: var_novelLastUpdateVolumeName,
        novelLastUpdateChapterName: var_novelLastUpdateChapterName,
        novelLastUpdateVolumeId: var_novelLastUpdateVolumeId,
        novelLastUpdateChapterId: var_novelLastUpdateChapterId,
        novelLastUpdateTime: var_novelLastUpdateTime,
        novelCover: var_novelCover,
        novelHotHits: var_novelHotHits,
        novelIntroduction: var_novelIntroduction,
        novelTypes: var_novelTypes,
        novelAuthors: var_novelAuthors,
        novelFirstLetter: var_novelFirstLetter,
        novelSubscribeNum: var_novelSubscribeNum,
        novelRedisUpdateTime: var_novelRedisUpdateTime,
        volumeId: var_volumeId,
        volumeTitle: var_volumeTitle,
        volumeOrder: var_volumeOrder,
        chapterId: var_chapterId,
        chapterTitle: var_chapterTitle,
        chapterOrder: var_chapterOrder,
        progress: var_progress,
        viewTime: var_viewTime);
  }

  @protected
  NovelVolume sse_decode_novel_volume(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_i_32(deserializer);
    var var_title = sse_decode_String(deserializer);
    var var_rank = sse_decode_i_32(deserializer);
    var var_chapters = sse_decode_list_novel_chapter(deserializer);
    return NovelVolume(
        id: var_id, title: var_title, rank: var_rank, chapters: var_chapters);
  }

  @protected
  NovelVolumeInfo sse_decode_novel_volume_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_i_32(deserializer);
    var var_novelId = sse_decode_i_32(deserializer);
    var var_title = sse_decode_String(deserializer);
    var var_rank = sse_decode_i_32(deserializer);
    var var_addTime = sse_decode_i_64(deserializer);
    var var_chaptersCount = sse_decode_i_32(deserializer);
    return NovelVolumeInfo(
        id: var_id,
        novelId: var_novelId,
        title: var_title,
        rank: var_rank,
        addTime: var_addTime,
        chaptersCount: var_chaptersCount);
  }

  @protected
  ComicViewLog? sse_decode_opt_box_autoadd_comic_view_log(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_comic_view_log(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_i_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  LoginData? sse_decode_opt_box_autoadd_login_data(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_login_data(deserializer));
    } else {
      return null;
    }
  }

  @protected
  NovelViewLog? sse_decode_opt_box_autoadd_novel_view_log(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_novel_view_log(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Subscribed sse_decode_subscribed(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_subUpdate = sse_decode_String(deserializer);
    var var_subImg = sse_decode_String(deserializer);
    var var_subUptime = sse_decode_i_64(deserializer);
    var var_subFirstLetter = sse_decode_String(deserializer);
    var var_subReaded = sse_decode_i_64(deserializer);
    var var_id = sse_decode_i_64(deserializer);
    var var_status = sse_decode_String(deserializer);
    return Subscribed(
        name: var_name,
        subUpdate: var_subUpdate,
        subImg: var_subImg,
        subUptime: var_subUptime,
        subFirstLetter: var_subFirstLetter,
        subReaded: var_subReaded,
        id: var_id,
        status: var_status);
  }

  @protected
  SummationsTask sse_decode_summations_task(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_signCount = sse_decode_i_64(deserializer);
    var var_maxSignCount = sse_decode_i_64(deserializer);
    var var_taskList = sse_decode_list_task_list(deserializer);
    return SummationsTask(
        signCount: var_signCount,
        maxSignCount: var_maxSignCount,
        taskList: var_taskList);
  }

  @protected
  Task sse_decode_task(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_i_64(deserializer);
    var var_title = sse_decode_String(deserializer);
    var var_con = sse_decode_String(deserializer);
    var var_icon = sse_decode_String(deserializer);
    var var_times = sse_decode_i_64(deserializer);
    var var_nums = sse_decode_i_64(deserializer);
    var var_source = sse_decode_i_64(deserializer);
    var var_typeId = sse_decode_i_64(deserializer);
    var var_url = sse_decode_String(deserializer);
    var var_btn = sse_decode_String(deserializer);
    var var_status = sse_decode_i_64(deserializer);
    var var_progress = sse_decode_i_64(deserializer);
    return Task(
        id: var_id,
        title: var_title,
        con: var_con,
        icon: var_icon,
        times: var_times,
        nums: var_nums,
        source: var_source,
        typeId: var_typeId,
        url: var_url,
        btn: var_btn,
        status: var_status,
        progress: var_progress);
  }

  @protected
  TaskIndex sse_decode_task_index(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_newPersonTask = sse_decode_list_task(deserializer);
    var var_dayTask = sse_decode_list_task(deserializer);
    var var_weekTask = sse_decode_list_task(deserializer);
    var var_summationsTask = sse_decode_summations_task(deserializer);
    var var_daySignTask = sse_decode_day_sign_task(deserializer);
    var var_creditsNums = sse_decode_i_64(deserializer);
    var var_silverNums = sse_decode_i_64(deserializer);
    var var_starsNums = sse_decode_i_64(deserializer);
    return TaskIndex(
        newPersonTask: var_newPersonTask,
        dayTask: var_dayTask,
        weekTask: var_weekTask,
        summationsTask: var_summationsTask,
        daySignTask: var_daySignTask,
        creditsNums: var_creditsNums,
        silverNums: var_silverNums,
        starsNums: var_starsNums);
  }

  @protected
  TaskList sse_decode_task_list(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_i_64(deserializer);
    var var_title = sse_decode_String(deserializer);
    var var_con = sse_decode_String(deserializer);
    var var_icon = sse_decode_String(deserializer);
    var var_times = sse_decode_i_64(deserializer);
    var var_nums = sse_decode_i_64(deserializer);
    var var_source = sse_decode_i_64(deserializer);
    var var_typeId = sse_decode_i_64(deserializer);
    var var_url = sse_decode_String(deserializer);
    var var_btn = sse_decode_String(deserializer);
    var var_status = sse_decode_i_64(deserializer);
    var var_progress = sse_decode_i_64(deserializer);
    var var_iconChecked = sse_decode_String(deserializer);
    return TaskList(
        id: var_id,
        title: var_title,
        con: var_con,
        icon: var_icon,
        times: var_times,
        nums: var_nums,
        source: var_source,
        typeId: var_typeId,
        url: var_url,
        btn: var_btn,
        status: var_status,
        progress: var_progress,
        iconChecked: var_iconChecked);
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_AnyhowException(
      AnyhowException self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_comic_detail(
      ComicDetail self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_comic_detail(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_comic_view_log(
      ComicViewLog self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_comic_view_log(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_login_data(
      LoginData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_login_data(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_novel_view_log(
      NovelViewLog self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_novel_view_log(self, serializer);
  }

  @protected
  void sse_encode_comic_category(ComicCategory self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.tagId, serializer);
    sse_encode_String(self.title, serializer);
    sse_encode_String(self.cover, serializer);
  }

  @protected
  void sse_encode_comic_chapter(ComicChapter self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.title, serializer);
    sse_encode_list_comic_chapter_info(self.data, serializer);
  }

  @protected
  void sse_encode_comic_chapter_detail(
      ComicChapterDetail self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.chapterId, serializer);
    sse_encode_i_64(self.comicId, serializer);
    sse_encode_String(self.title, serializer);
    sse_encode_i_32(self.chapterOrder, serializer);
    sse_encode_i_32(self.direction, serializer);
    sse_encode_list_String(self.pageUrl, serializer);
    sse_encode_i_32(self.picnum, serializer);
    sse_encode_list_String(self.pageUrlHd, serializer);
    sse_encode_i_32(self.commentCount, serializer);
  }

  @protected
  void sse_encode_comic_chapter_info(
      ComicChapterInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.chapterId, serializer);
    sse_encode_String(self.chapterTitle, serializer);
    sse_encode_i_64(self.updateTime, serializer);
    sse_encode_i_32(self.fileSize, serializer);
    sse_encode_i_32(self.chapterOrder, serializer);
  }

  @protected
  void sse_encode_comic_detail(ComicDetail self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.id, serializer);
    sse_encode_String(self.title, serializer);
    sse_encode_i_32(self.direction, serializer);
    sse_encode_i_32(self.isLong, serializer);
    sse_encode_i_32(self.isAnimeHome, serializer);
    sse_encode_String(self.cover, serializer);
    sse_encode_String(self.description, serializer);
    sse_encode_i_64(self.lastUpdateTime, serializer);
    sse_encode_String(self.lastUpdateChapterName, serializer);
    sse_encode_i_32(self.copyright, serializer);
    sse_encode_String(self.firstLetter, serializer);
    sse_encode_String(self.comicPy, serializer);
    sse_encode_i_32(self.hidden, serializer);
    sse_encode_i_32(self.hotNum, serializer);
    sse_encode_i_32(self.hitNum, serializer);
    sse_encode_i_32(self.uid, serializer);
    sse_encode_i_32(self.isLock, serializer);
    sse_encode_i_32(self.lastUpdateChapterId, serializer);
    sse_encode_list_item(self.types, serializer);
    sse_encode_list_item(self.status, serializer);
    sse_encode_list_item(self.authors, serializer);
    sse_encode_i_32(self.subscribeNum, serializer);
    sse_encode_list_comic_chapter(self.chapters, serializer);
    sse_encode_i_32(self.isNeedLogin, serializer);
    sse_encode_i_32(self.isHideChapter, serializer);
  }

  @protected
  void sse_encode_comic_filter(ComicFilter self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.title, serializer);
    sse_encode_list_comic_filter_item(self.items, serializer);
  }

  @protected
  void sse_encode_comic_filter_item(
      ComicFilterItem self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.tagId, serializer);
    sse_encode_String(self.tagName, serializer);
  }

  @protected
  void sse_encode_comic_in_filter(
      ComicInFilter self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.id, serializer);
    sse_encode_String(self.title, serializer);
    sse_encode_String(self.authors, serializer);
    sse_encode_String(self.status, serializer);
    sse_encode_String(self.cover, serializer);
    sse_encode_String(self.types, serializer);
    sse_encode_i_64(self.lastUpdateTime, serializer);
    sse_encode_i_64(self.num, serializer);
  }

  @protected
  void sse_encode_comic_in_search(
      ComicInSearch self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.biz, serializer);
    sse_encode_i_64(self.addtime, serializer);
    sse_encode_String(self.authors, serializer);
    sse_encode_i_64(self.copyright, serializer);
    sse_encode_String(self.cover, serializer);
    sse_encode_i_64(self.hidden, serializer);
    sse_encode_i_64(self.hotHits, serializer);
    sse_encode_String(self.lastName, serializer);
    sse_encode_i_64(self.status, serializer);
    sse_encode_String(self.title, serializer);
    sse_encode_String(self.types, serializer);
    sse_encode_i_64(self.id, serializer);
  }

  @protected
  void sse_encode_comic_rank_list_item(
      ComicRankListItem self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.id, serializer);
    sse_encode_String(self.title, serializer);
    sse_encode_String(self.authors, serializer);
    sse_encode_String(self.status, serializer);
    sse_encode_String(self.cover, serializer);
    sse_encode_String(self.types, serializer);
    sse_encode_i_64(self.lastUpdateTime, serializer);
    sse_encode_String(self.lastUpdateChapterName, serializer);
    sse_encode_String(self.comicPy, serializer);
    sse_encode_i_32(self.num, serializer);
    sse_encode_i_32(self.tagId, serializer);
    sse_encode_String(self.chapterName, serializer);
    sse_encode_i_32(self.chapterId, serializer);
  }

  @protected
  void sse_encode_comic_update_list_item(
      ComicUpdateListItem self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.id, serializer);
    sse_encode_String(self.title, serializer);
    sse_encode_bool(self.isLong, serializer);
    sse_encode_String(self.authors, serializer);
    sse_encode_String(self.types, serializer);
    sse_encode_String(self.cover, serializer);
    sse_encode_String(self.status, serializer);
    sse_encode_String(self.lastUpdateChapterName, serializer);
    sse_encode_i_32(self.lastUpdateChapterId, serializer);
    sse_encode_i_64(self.lastUpdateTime, serializer);
  }

  @protected
  void sse_encode_comic_view_log(ComicViewLog self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.comicId, serializer);
    sse_encode_String(self.comicTitle, serializer);
    sse_encode_String(self.comicAuthors, serializer);
    sse_encode_String(self.comicStatus, serializer);
    sse_encode_String(self.comicCover, serializer);
    sse_encode_String(self.comicTypes, serializer);
    sse_encode_i_64(self.comicLastUpdateTime, serializer);
    sse_encode_String(self.comicLastUpdateChapterName, serializer);
    sse_encode_i_32(self.chapterId, serializer);
    sse_encode_String(self.chapterTitle, serializer);
    sse_encode_i_32(self.chapterOrder, serializer);
    sse_encode_i_32(self.pageRank, serializer);
    sse_encode_i_64(self.viewTime, serializer);
  }

  @protected
  void sse_encode_comment(Comment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.id, serializer);
    sse_encode_i_64(self.isPassed, serializer);
    sse_encode_i_64(self.topStatus, serializer);
    sse_encode_i_64(self.isGoods, serializer);
    sse_encode_String(self.uploadImages, serializer);
    sse_encode_i_64(self.objId, serializer);
    sse_encode_String(self.content, serializer);
    sse_encode_i_64(self.senderUid, serializer);
    sse_encode_i_64(self.likeAmount, serializer);
    sse_encode_i_64(self.createTime, serializer);
    sse_encode_i_64(self.toUid, serializer);
    sse_encode_i_64(self.toCommentId, serializer);
    sse_encode_i_64(self.originCommentId, serializer);
    sse_encode_i_64(self.replyAmount, serializer);
    sse_encode_i_64(self.hotCommentAmount, serializer);
    sse_encode_String(self.cover, serializer);
    sse_encode_String(self.nickname, serializer);
    sse_encode_String(self.avatarUrl, serializer);
    sse_encode_i_64(self.sex, serializer);
    sse_encode_i_64(self.masterCommentNum, serializer);
    sse_encode_list_master_comment(self.masterComment, serializer);
  }

  @protected
  void sse_encode_day_list(DayList self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.id, serializer);
    sse_encode_String(self.title, serializer);
    sse_encode_String(self.icon, serializer);
    sse_encode_String(self.iconChecked, serializer);
    sse_encode_i_64(self.typeId, serializer);
    sse_encode_i_64(self.times, serializer);
    sse_encode_i_64(self.nums, serializer);
    sse_encode_i_64(self.creditsNums, serializer);
  }

  @protected
  void sse_encode_day_sign_task(DaySignTask self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.currentDay, serializer);
    sse_encode_i_64(self.status, serializer);
    sse_encode_i_64(self.doubleStatus, serializer);
    sse_encode_list_day_list(self.dayList, serializer);
  }

  @protected
  void sse_encode_download_comic(DownloadComic self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.id, serializer);
    sse_encode_String(self.title, serializer);
    sse_encode_String(self.authors, serializer);
    sse_encode_String(self.types, serializer);
    sse_encode_String(self.status, serializer);
    sse_encode_i_32(self.direction, serializer);
    sse_encode_i_32(self.isLong, serializer);
    sse_encode_i_32(self.isAnimeHome, serializer);
    sse_encode_String(self.cover, serializer);
    sse_encode_String(self.description, serializer);
    sse_encode_i_32(self.copyright, serializer);
    sse_encode_String(self.firstLetter, serializer);
    sse_encode_String(self.comicPy, serializer);
    sse_encode_i_32(self.coverDownloadStatus, serializer);
    sse_encode_String(self.coverFormat, serializer);
    sse_encode_u_32(self.coverWidth, serializer);
    sse_encode_u_32(self.coverHeight, serializer);
    sse_encode_i_32(self.downloadStatus, serializer);
    sse_encode_i_32(self.imageCount, serializer);
    sse_encode_i_32(self.imageCountDownload, serializer);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_i_64(PlatformInt64 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putPlatformInt64(self);
  }

  @protected
  void sse_encode_item(Item self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.id, serializer);
    sse_encode_String(self.title, serializer);
  }

  @protected
  void sse_encode_list_String(List<String> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_String(item, serializer);
    }
  }

  @protected
  void sse_encode_list_comic_category(
      List<ComicCategory> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_comic_category(item, serializer);
    }
  }

  @protected
  void sse_encode_list_comic_chapter(
      List<ComicChapter> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_comic_chapter(item, serializer);
    }
  }

  @protected
  void sse_encode_list_comic_chapter_info(
      List<ComicChapterInfo> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_comic_chapter_info(item, serializer);
    }
  }

  @protected
  void sse_encode_list_comic_filter(
      List<ComicFilter> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_comic_filter(item, serializer);
    }
  }

  @protected
  void sse_encode_list_comic_filter_item(
      List<ComicFilterItem> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_comic_filter_item(item, serializer);
    }
  }

  @protected
  void sse_encode_list_comic_in_filter(
      List<ComicInFilter> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_comic_in_filter(item, serializer);
    }
  }

  @protected
  void sse_encode_list_comic_in_search(
      List<ComicInSearch> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_comic_in_search(item, serializer);
    }
  }

  @protected
  void sse_encode_list_comic_rank_list_item(
      List<ComicRankListItem> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_comic_rank_list_item(item, serializer);
    }
  }

  @protected
  void sse_encode_list_comic_update_list_item(
      List<ComicUpdateListItem> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_comic_update_list_item(item, serializer);
    }
  }

  @protected
  void sse_encode_list_comic_view_log(
      List<ComicViewLog> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_comic_view_log(item, serializer);
    }
  }

  @protected
  void sse_encode_list_comment(List<Comment> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_comment(item, serializer);
    }
  }

  @protected
  void sse_encode_list_day_list(List<DayList> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_day_list(item, serializer);
    }
  }

  @protected
  void sse_encode_list_download_comic(
      List<DownloadComic> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_download_comic(item, serializer);
    }
  }

  @protected
  void sse_encode_list_item(List<Item> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_item(item, serializer);
    }
  }

  @protected
  void sse_encode_list_master_comment(
      List<MasterComment> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_master_comment(item, serializer);
    }
  }

  @protected
  void sse_encode_list_news_category(
      List<NewsCategory> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_news_category(item, serializer);
    }
  }

  @protected
  void sse_encode_list_news_list_item(
      List<NewsListItem> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_news_list_item(item, serializer);
    }
  }

  @protected
  void sse_encode_list_novel_category(
      List<NovelCategory> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_novel_category(item, serializer);
    }
  }

  @protected
  void sse_encode_list_novel_chapter(
      List<NovelChapter> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_novel_chapter(item, serializer);
    }
  }

  @protected
  void sse_encode_list_novel_in_filter(
      List<NovelInFilter> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_novel_in_filter(item, serializer);
    }
  }

  @protected
  void sse_encode_list_novel_in_search(
      List<NovelInSearch> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_novel_in_search(item, serializer);
    }
  }

  @protected
  void sse_encode_list_novel_view_log(
      List<NovelViewLog> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_novel_view_log(item, serializer);
    }
  }

  @protected
  void sse_encode_list_novel_volume(
      List<NovelVolume> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_novel_volume(item, serializer);
    }
  }

  @protected
  void sse_encode_list_novel_volume_info(
      List<NovelVolumeInfo> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_novel_volume_info(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_i_32_loose(
      List<int> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer
        .putInt32List(self is Int32List ? self : Int32List.fromList(self));
  }

  @protected
  void sse_encode_list_prim_i_32_strict(
      Int32List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putInt32List(self);
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
      Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_subscribed(
      List<Subscribed> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_subscribed(item, serializer);
    }
  }

  @protected
  void sse_encode_list_task(List<Task> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_task(item, serializer);
    }
  }

  @protected
  void sse_encode_list_task_list(
      List<TaskList> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_task_list(item, serializer);
    }
  }

  @protected
  void sse_encode_local_image(LocalImage self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.absPath, serializer);
    sse_encode_String(self.localPath, serializer);
    sse_encode_String(self.imageFormat, serializer);
    sse_encode_u_32(self.imageWidth, serializer);
    sse_encode_u_32(self.imageHeight, serializer);
  }

  @protected
  void sse_encode_login_data(LoginData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.uid, serializer);
    sse_encode_String(self.nickname, serializer);
    sse_encode_String(self.dmzjToken, serializer);
    sse_encode_String(self.photo, serializer);
    sse_encode_String(self.bindPhone, serializer);
    sse_encode_String(self.email, serializer);
    sse_encode_String(self.passwd, serializer);
  }

  @protected
  void sse_encode_login_info(LoginInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.status, serializer);
    sse_encode_String(self.message, serializer);
    sse_encode_opt_box_autoadd_login_data(self.data, serializer);
  }

  @protected
  void sse_encode_master_comment(MasterComment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.id, serializer);
    sse_encode_i_64(self.isPassed, serializer);
    sse_encode_i_64(self.topStatus, serializer);
    sse_encode_i_64(self.isGoods, serializer);
    sse_encode_String(self.uploadImages, serializer);
    sse_encode_i_64(self.objId, serializer);
    sse_encode_String(self.content, serializer);
    sse_encode_i_64(self.senderUid, serializer);
    sse_encode_i_64(self.likeAmount, serializer);
    sse_encode_i_64(self.createTime, serializer);
    sse_encode_i_64(self.toUid, serializer);
    sse_encode_i_64(self.toCommentId, serializer);
    sse_encode_i_64(self.originCommentId, serializer);
    sse_encode_i_64(self.replyAmount, serializer);
    sse_encode_String(self.cover, serializer);
    sse_encode_String(self.nickname, serializer);
    sse_encode_i_64(self.hotCommentAmount, serializer);
    sse_encode_i_64(self.sex, serializer);
  }

  @protected
  void sse_encode_news_category(NewsCategory self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.tagId, serializer);
    sse_encode_String(self.tagName, serializer);
  }

  @protected
  void sse_encode_news_list_item(NewsListItem self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.id, serializer);
    sse_encode_String(self.title, serializer);
    sse_encode_String(self.fromName, serializer);
    sse_encode_String(self.fromUrl, serializer);
    sse_encode_i_64(self.createTime, serializer);
    sse_encode_i_32(self.isForeign, serializer);
    sse_encode_String(self.foreignUrl, serializer);
    sse_encode_String(self.intro, serializer);
    sse_encode_i_32(self.authorId, serializer);
    sse_encode_i_32(self.status, serializer);
    sse_encode_String(self.rowPicUrl, serializer);
    sse_encode_String(self.colPicUrl, serializer);
    sse_encode_i_32(self.qChatShow, serializer);
    sse_encode_String(self.pageUrl, serializer);
    sse_encode_i_32(self.commentAmount, serializer);
    sse_encode_i_32(self.authorUid, serializer);
    sse_encode_String(self.cover, serializer);
    sse_encode_String(self.nickname, serializer);
    sse_encode_i_32(self.moodAmount, serializer);
  }

  @protected
  void sse_encode_novel_category(NovelCategory self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.tagId, serializer);
    sse_encode_String(self.title, serializer);
    sse_encode_String(self.cover, serializer);
  }

  @protected
  void sse_encode_novel_chapter(NovelChapter self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.chapterId, serializer);
    sse_encode_String(self.chapterName, serializer);
    sse_encode_i_32(self.chapterOrder, serializer);
  }

  @protected
  void sse_encode_novel_detail(NovelDetail self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.id, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.zone, serializer);
    sse_encode_String(self.status, serializer);
    sse_encode_String(self.lastUpdateVolumeName, serializer);
    sse_encode_String(self.lastUpdateChapterName, serializer);
    sse_encode_i_32(self.lastUpdateVolumeId, serializer);
    sse_encode_i_32(self.lastUpdateChapterId, serializer);
    sse_encode_i_64(self.lastUpdateTime, serializer);
    sse_encode_String(self.cover, serializer);
    sse_encode_i_32(self.hotHits, serializer);
    sse_encode_String(self.introduction, serializer);
    sse_encode_list_String(self.types, serializer);
    sse_encode_String(self.authors, serializer);
    sse_encode_String(self.firstLetter, serializer);
    sse_encode_i_32(self.subscribeNum, serializer);
    sse_encode_i_64(self.redisUpdateTime, serializer);
    sse_encode_list_novel_volume_info(self.volumes, serializer);
  }

  @protected
  void sse_encode_novel_in_filter(
      NovelInFilter self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.cover, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.authors, serializer);
    sse_encode_i_64(self.id, serializer);
  }

  @protected
  void sse_encode_novel_in_search(
      NovelInSearch self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.biz, serializer);
    sse_encode_i_64(self.addtime, serializer);
    sse_encode_String(self.authors, serializer);
    sse_encode_i_64(self.copyright, serializer);
    sse_encode_String(self.cover, serializer);
    sse_encode_i_64(self.hidden, serializer);
    sse_encode_i_64(self.hotHits, serializer);
    sse_encode_String(self.lastName, serializer);
    sse_encode_i_64(self.status, serializer);
    sse_encode_String(self.title, serializer);
    sse_encode_String(self.types, serializer);
    sse_encode_i_64(self.id, serializer);
  }

  @protected
  void sse_encode_novel_view_log(NovelViewLog self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.novelId, serializer);
    sse_encode_String(self.novelTitle, serializer);
    sse_encode_String(self.novelZone, serializer);
    sse_encode_String(self.novelStatus, serializer);
    sse_encode_String(self.novelLastUpdateVolumeName, serializer);
    sse_encode_String(self.novelLastUpdateChapterName, serializer);
    sse_encode_i_32(self.novelLastUpdateVolumeId, serializer);
    sse_encode_i_32(self.novelLastUpdateChapterId, serializer);
    sse_encode_i_64(self.novelLastUpdateTime, serializer);
    sse_encode_String(self.novelCover, serializer);
    sse_encode_i_32(self.novelHotHits, serializer);
    sse_encode_String(self.novelIntroduction, serializer);
    sse_encode_String(self.novelTypes, serializer);
    sse_encode_String(self.novelAuthors, serializer);
    sse_encode_String(self.novelFirstLetter, serializer);
    sse_encode_i_32(self.novelSubscribeNum, serializer);
    sse_encode_i_64(self.novelRedisUpdateTime, serializer);
    sse_encode_i_32(self.volumeId, serializer);
    sse_encode_String(self.volumeTitle, serializer);
    sse_encode_i_32(self.volumeOrder, serializer);
    sse_encode_i_32(self.chapterId, serializer);
    sse_encode_String(self.chapterTitle, serializer);
    sse_encode_i_32(self.chapterOrder, serializer);
    sse_encode_i_64(self.progress, serializer);
    sse_encode_i_64(self.viewTime, serializer);
  }

  @protected
  void sse_encode_novel_volume(NovelVolume self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.id, serializer);
    sse_encode_String(self.title, serializer);
    sse_encode_i_32(self.rank, serializer);
    sse_encode_list_novel_chapter(self.chapters, serializer);
  }

  @protected
  void sse_encode_novel_volume_info(
      NovelVolumeInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.id, serializer);
    sse_encode_i_32(self.novelId, serializer);
    sse_encode_String(self.title, serializer);
    sse_encode_i_32(self.rank, serializer);
    sse_encode_i_64(self.addTime, serializer);
    sse_encode_i_32(self.chaptersCount, serializer);
  }

  @protected
  void sse_encode_opt_box_autoadd_comic_view_log(
      ComicViewLog? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_comic_view_log(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_i_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_i_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_login_data(
      LoginData? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_login_data(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_novel_view_log(
      NovelViewLog? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_novel_view_log(self, serializer);
    }
  }

  @protected
  void sse_encode_subscribed(Subscribed self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.subUpdate, serializer);
    sse_encode_String(self.subImg, serializer);
    sse_encode_i_64(self.subUptime, serializer);
    sse_encode_String(self.subFirstLetter, serializer);
    sse_encode_i_64(self.subReaded, serializer);
    sse_encode_i_64(self.id, serializer);
    sse_encode_String(self.status, serializer);
  }

  @protected
  void sse_encode_summations_task(
      SummationsTask self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.signCount, serializer);
    sse_encode_i_64(self.maxSignCount, serializer);
    sse_encode_list_task_list(self.taskList, serializer);
  }

  @protected
  void sse_encode_task(Task self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.id, serializer);
    sse_encode_String(self.title, serializer);
    sse_encode_String(self.con, serializer);
    sse_encode_String(self.icon, serializer);
    sse_encode_i_64(self.times, serializer);
    sse_encode_i_64(self.nums, serializer);
    sse_encode_i_64(self.source, serializer);
    sse_encode_i_64(self.typeId, serializer);
    sse_encode_String(self.url, serializer);
    sse_encode_String(self.btn, serializer);
    sse_encode_i_64(self.status, serializer);
    sse_encode_i_64(self.progress, serializer);
  }

  @protected
  void sse_encode_task_index(TaskIndex self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_task(self.newPersonTask, serializer);
    sse_encode_list_task(self.dayTask, serializer);
    sse_encode_list_task(self.weekTask, serializer);
    sse_encode_summations_task(self.summationsTask, serializer);
    sse_encode_day_sign_task(self.daySignTask, serializer);
    sse_encode_i_64(self.creditsNums, serializer);
    sse_encode_i_64(self.silverNums, serializer);
    sse_encode_i_64(self.starsNums, serializer);
  }

  @protected
  void sse_encode_task_list(TaskList self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.id, serializer);
    sse_encode_String(self.title, serializer);
    sse_encode_String(self.con, serializer);
    sse_encode_String(self.icon, serializer);
    sse_encode_i_64(self.times, serializer);
    sse_encode_i_64(self.nums, serializer);
    sse_encode_i_64(self.source, serializer);
    sse_encode_i_64(self.typeId, serializer);
    sse_encode_String(self.url, serializer);
    sse_encode_String(self.btn, serializer);
    sse_encode_i_64(self.status, serializer);
    sse_encode_i_64(self.progress, serializer);
    sse_encode_String(self.iconChecked, serializer);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }
}
